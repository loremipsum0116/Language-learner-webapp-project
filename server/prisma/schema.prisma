generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "foreignKeys"
}

model category {
  id          Int         @id @default(autoincrement())
  userId      Int
  name        String
  createdAt   DateTime    @default(now())
  kind        String      @default("wordbook")
  nextAlarmAt DateTime?
  alarmActive Boolean     @default(true)
  remindEvery Int?
  user        user        @relation(fields: [userId], references: [id], onDelete: Cascade, map: "Category_userId_fkey")
  srscard     srscard[]
  uservocab   uservocab[]

  @@unique([userId, name], map: "Category_userId_name_key")
}

model dailystudystat {
  id           Int      @id @default(autoincrement())
  userId       Int
  date         DateTime
  srsSolved    Int      @default(0)
  autoLearned  Int      @default(0)
  wrongDueNext Int      @default(0)
  createdAt    DateTime @default(now())
  user         user     @relation(fields: [userId], references: [id], onDelete: Cascade, map: "DailyStudyStat_userId_fkey")

  @@unique([userId, date], map: "DailyStudyStat_userId_date_key")
}

model dictentry {
  id          Int       @id @default(autoincrement())
  vocabId     Int       @unique(map: "DictEntry_vocabId_key")
  ipa         String?
  audioUrl    String?
  audioLocal  String?
  license     String?
  attribution String?
  sourceUrl   String?
  retrievedAt DateTime?
  examples    Json
  ipaKo       String?
  vocab       vocab     @relation(fields: [vocabId], references: [id], onDelete: Cascade, map: "DictEntry_vocabId_fkey")
}

model grammarexercise {
  id        Int    @id @default(autoincrement())
  topicId   String @unique(map: "GrammarExercise_topicId_key")
  topic     String
  levelCEFR String
  items     Json
}

model grammaritem {
  id       Int    @id @default(autoincrement())
  topic    String
  rule     String
  examples Json
}

model reading {
  id        Int    @id @default(autoincrement())
  title     String
  body      String
  levelCEFR String
  glosses   Json
}

model sessionbatch {
  id        Int      @id @default(autoincrement())
  userId    Int
  createdAt DateTime @default(now())
  order     Int
  cards     Json
}

model srscard {
  id                Int             @id @default(autoincrement())
  userId            Int
  itemType          String
  itemId            Int
  stage             Int             @default(0)
  nextReviewAt      DateTime?
  categoryId        Int?
  correctTotal      Int             @default(0)
  wrongTotal        Int             @default(0)
  cohortDate        DateTime?
  isOverdue         Boolean         @default(false)
  overdueDeadline   DateTime?
  isFromWrongAnswer Boolean         @default(false)
  waitingUntil      DateTime?
  frozenUntil       DateTime?
  folderId          Int?
  isMastered        Boolean         @default(false)
  masterCycles      Int             @default(0)
  masteredAt        DateTime?
  overdueStartAt    DateTime?
  wrongStreakCount  Int             @default(0)
  lastReviewedAt    DateTime?
  isTodayStudy      Boolean         @default(false)
  todayFirstResult  Boolean?
  todayStudyDate    DateTime?
  category          category?       @relation(fields: [categoryId], references: [id], map: "SRSCard_categoryId_fkey")
  folder            srsfolder?      @relation(fields: [folderId], references: [id], onDelete: Cascade, map: "SRSCard_folderId_fkey")
  user              user            @relation(fields: [userId], references: [id], onDelete: Cascade, map: "SRSCard_userId_fkey")
  srsfolderitem     srsfolderitem[]

  @@unique([userId, itemType, itemId, folderId], map: "SRSCard_userId_itemType_itemId_folderId_key")
  @@index([categoryId], map: "SRSCard_categoryId_fkey")
  @@index([folderId], map: "SRSCard_folderId_fkey")
  @@index([userId, isMastered], map: "SRSCard_userId_isMastered_idx")
  @@index([userId, nextReviewAt], map: "SRSCard_userId_nextReviewAt_idx")
}

model srsfolder {
  id                  Int             @id @default(autoincrement())
  userId              Int
  parentId            Int?
  name                String
  createdDate         DateTime        @db.Date
  stage               Int             @default(0)
  nextReviewDate      DateTime?       @db.Date
  lastReviewedAt      DateTime?
  nextReviewAt        DateTime?
  alarmActive         Boolean         @default(true)
  nextAlarmAt         DateTime?
  completedAt         DateTime?
  cycleAnchorAt       DateTime        @default(now())
  kind                String          @default("manual")
  scheduledOffset     Int?
  autoCreated         Boolean         @default(false)
  originSessionId     Int?
  isCompleted         Boolean         @default(false)
  completedWordsCount Int             @default(0)
  completionCount     Int             @default(0)
  isMastered          Boolean         @default(false)
  date                DateTime        @default(now())
  createdAt           DateTime        @default(now())
  updatedAt           DateTime
  reminderMask        Int             @default(0)
  learningCurveType   String          @default("long")
  isFolderMastered    Boolean         @default(false)
  folderMasteredAt    DateTime?
  srscard             srscard[]
  user                user            @relation(fields: [userId], references: [id], onDelete: Cascade, map: "SrsFolder_userId_fkey")
  srsfolderitem       srsfolderitem[]
  uservocab           uservocab[]
  wronganswer         wronganswer[]

  @@index([nextAlarmAt], map: "SrsFolder_nextAlarmAt_idx")
  @@index([parentId], map: "SrsFolder_parentId_idx")
  @@index([userId, alarmActive, nextReviewAt], map: "SrsFolder_userId_alarmActive_nextReviewAt_idx")
}

model srsfolderitem {
  id             Int       @id @default(autoincrement())
  folderId       Int
  cardId         Int
  learned        Boolean   @default(false)
  wrongCount     Int       @default(0)
  lastReviewedAt DateTime?
  vocabId        Int?
  lastWrongAt    DateTime?
  srscard        srscard   @relation(fields: [cardId], references: [id], onDelete: Cascade, map: "SrsFolderItem_cardId_fkey")
  srsfolder      srsfolder @relation(fields: [folderId], references: [id], onDelete: Cascade, map: "SrsFolderItem_folderId_fkey")
  vocab          vocab?    @relation(fields: [vocabId], references: [id], onDelete: Cascade, map: "SrsFolderItem_vocabId_fkey")

  @@unique([folderId, cardId], map: "SrsFolderItem_folderId_cardId_key")
  @@unique([folderId, vocabId], map: "SrsFolderItem_folderId_vocabId_key")
  @@index([cardId], map: "SrsFolderItem_cardId_idx")
  @@index([folderId, learned], map: "SrsFolderItem_folderId_learned_idx")
  @@index([vocabId], map: "SrsFolderItem_vocabId_fkey")
}

model tutorlog {
  id        Int      @id @default(autoincrement())
  userId    Int
  mode      String
  input     String
  output    String
  tokens    Int?
  cost      Float?
  refs      Json?
  createdAt DateTime @default(now())
  user      user     @relation(fields: [userId], references: [id], map: "TutorLog_userId_fkey")

  @@index([userId], map: "TutorLog_userId_fkey")
}

model user {
  id               Int              @id @default(autoincrement())
  email            String           @unique(map: "User_email_key")
  passwordHash     String
  role             String           @default("USER")
  profile          Json?
  createdAt        DateTime         @default(now())
  lastStudiedAt    DateTime?
  streak           Int              @default(0)
  streakUpdatedAt  DateTime?
  dailyQuizCount   Int              @default(0)
  lastQuizDate     DateTime?
  hasOverdueCards  Boolean          @default(false)
  lastOverdueCheck DateTime?
  nextOverdueAlarm DateTime?
  category         category[]
  dailystudystat   dailystudystat[]
  refreshToken     refreshToken[]
  srscard          srscard[]
  srsfolder        srsfolder[]
  tutorlog         tutorlog[]
  uservocab        uservocab[]
  wronganswer      wronganswer[]
}

model uservocab {
  id         Int        @id @default(autoincrement())
  userId     Int
  vocabId    Int
  createdAt  DateTime   @default(now())
  categoryId Int?
  folderId   Int?
  category   category?  @relation(fields: [categoryId], references: [id], map: "UserVocab_categoryId_fkey")
  folder     srsfolder? @relation(fields: [folderId], references: [id], onDelete: Cascade, map: "UserVocab_folderId_fkey")
  user       user       @relation(fields: [userId], references: [id], onDelete: Cascade, map: "UserVocab_userId_fkey")
  vocab      vocab      @relation(fields: [vocabId], references: [id], onDelete: Cascade, map: "UserVocab_vocabId_fkey")

  @@unique([userId, vocabId, folderId], map: "UserVocab_userId_vocabId_folderId_key")
  @@index([categoryId], map: "UserVocab_categoryId_fkey")
  @@index([folderId], map: "UserVocab_folderId_fkey")
  @@index([userId, categoryId], map: "UserVocab_userId_categoryId_idx")
  @@index([userId, folderId], map: "UserVocab_userId_folderId_idx")
  @@index([vocabId], map: "UserVocab_vocabId_fkey")
}

model vocab {
  id                Int                 @id @default(autoincrement())
  lemma             String
  pos               String
  plural            String?
  levelCEFR         String
  freq              Int?
  source            String?
  dictentry         dictentry?
  srsfolderitem     srsfolderitem[]
  uservocab         uservocab[]
  vocabexamcategory vocabexamcategory[]
  wronganswer       wronganswer[]

  @@index([lemma], map: "Vocab_lemma_idx")
  @@index([source], map: "Vocab_source_idx")
}

model wronganswer {
  id                Int        @id @default(autoincrement())
  userId            Int
  vocabId           Int?
  wrongAt           DateTime   @default(now())
  reviewWindowStart DateTime
  reviewWindowEnd   DateTime
  reviewedAt        DateTime?
  isCompleted       Boolean    @default(false)
  attempts          Int        @default(0)
  folderId          Int?
  itemId            Int
  itemType          String     @default("vocab")
  wrongData         Json?
  folder            srsfolder? @relation(fields: [folderId], references: [id], onDelete: Cascade, map: "WrongAnswer_folderId_fkey")
  user              user       @relation(fields: [userId], references: [id], onDelete: Cascade, map: "WrongAnswer_userId_fkey")
  vocab             vocab?     @relation(fields: [vocabId], references: [id], onDelete: Cascade, map: "WrongAnswer_vocabId_fkey")

  @@unique([userId, itemType, itemId, folderId, wrongAt], map: "WrongAnswer_userId_itemType_itemId_folderId_wrongAt_key")
  @@index([reviewWindowStart, reviewWindowEnd], map: "WrongAnswer_reviewWindowStart_reviewWindowEnd_idx")
  @@index([userId, isCompleted], map: "WrongAnswer_userId_isCompleted_idx")
  @@index([userId, itemType], map: "WrongAnswer_userId_itemType_idx")
  @@index([vocabId], map: "WrongAnswer_vocabId_fkey")
  @@index([folderId], map: "WrongAnswer_folderId_fkey")
}

model examcategory {
  id                Int                 @id @default(autoincrement()) @map("id")
  name              String              @unique
  description       String?
  totalWords        Int                 @default(0)
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  vocabexamcategory vocabexamcategory[]

  @@map("exam_categories")
}

model vocabexamcategory {
  id             Int          @id @default(autoincrement())
  vocabId        Int
  examCategoryId Int
  priority       Int          @default(0)
  addedAt        DateTime     @default(now())
  examCategory   examcategory @relation(fields: [examCategoryId], references: [id], onDelete: Cascade)
  vocab          vocab        @relation(fields: [vocabId], references: [id], onDelete: Cascade)

  @@unique([vocabId, examCategoryId])
  @@index([examCategoryId])
  @@index([vocabId])
  @@map("vocab_exam_categories")
}

model readingRecord {
  id            Int      @id @default(autoincrement())
  userId        Int
  questionId    String
  level         String
  isCorrect     Boolean
  userAnswer    String
  correctAnswer String
  solvedAt      DateTime @default(now())

  @@unique([userId, questionId, level])
  @@index([userId, level])
  @@map("reading_records")
}

model listeningRecord {
  id            Int      @id @default(autoincrement())
  userId        Int
  questionId    String
  level         String
  isCorrect     Boolean
  userAnswer    String
  correctAnswer String
  solvedAt      DateTime @default(now())

  @@unique([userId, questionId, level])
  @@index([userId, level])
  @@map("listening_records")
}

model refreshToken {
  id          Int      @id @default(autoincrement())
  userId      Int
  token       String   @unique
  deviceId    String?
  deviceName  String?
  userAgent   String?
  ipAddress   String?
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  lastUsedAt  DateTime @default(now())
  isRevoked   Boolean  @default(false)
  revokedAt   DateTime?
  user        user     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("refresh_tokens")
}
