# 일본어 SRS 퀴즈 시스템 구현 진행사항

## 프로젝트 개요
일본어 전용 SRS 퀴즈 시스템을 구현하여 영어와 분리된 퀴즈 타입들을 제공

## 구현할 퀴즈 타입들
1. 일본어 단어 → 한국어 뜻 (4지선다)
2. 한국어 뜻 → 일본어 단어 (4지선다)
3. 예문 빈칸 스펠링 입력 (한자/로마자 모두 정답 처리)
4. 일본어 단어 → 로마자 발음 (4지선다)

## 진행사항

### 2025-09-16
- 프로젝트 시작 및 현재 SRS 퀴즈 시스템 구조 분석 완료
- 현재 SrsQuiz.jsx와 srsService.js 파일 구조 확인 완료
- 영어 중심의 기존 퀴즈 시스템을 일본어 확장하기 위한 기반 파악

#### 완료된 작업들:
1. **일본어 전용 퀴즈 타입 정의 완료**
   - `/web/apps/frontend/src/types/japanese-quiz.js` 생성
   - 4가지 일본어 퀴즈 타입 정의: jp_word_to_ko_meaning, ko_meaning_to_jp_word, jp_fill_in_blank, jp_word_to_romaji
   - 타입스크립트 타입 정의 및 헬퍼 함수들 구현

2. **백엔드 퀴즈 생성 서비스 확장 완료**
   - `/web/apps/backend/services/quizService.js` 확장
   - 4가지 일본어 퀴즈 생성 함수 구현:
     - generateJapaneseToKoreanQuiz(): 일본어 단어 → 한국어 뜻 (4지선다)
     - generateKoreanToJapaneseQuiz(): 한국어 뜻 → 일본어 단어 (4지선다)
     - generateJapaneseToRomajiQuiz(): 일본어 단어 → 로마자 발음 (4지선다)
     - generateJapaneseFillInBlankQuiz(): 예문 빈칸 스펠링 입력 (한자/로마자 모두 정답 처리)
   - detectLanguage() 함수로 JLPT 단어 자동 감지
   - generateQuizByLanguageAndType() 메인 함수로 언어별 퀴즈 생성 통합

3. **백엔드 라우팅 확장 완료**
   - `/web/apps/backend/routes/quiz.js` 확장
   - 새로운 엔드포인트 추가:
     - POST `/quiz/japanese`: 일본어 전용 퀴즈 생성
     - POST `/quiz/by-language`: 언어별 퀴즈 생성 (자동 감지 지원)
   - 기존 영어 퀴즈와 호환성 유지

4. **프론트엔드 일본어 퀴즈 컴포넌트 완료**
   - `/web/apps/frontend/src/components/JapaneseQuiz.jsx` 생성
   - 4가지 퀴즈 타입 모두 지원
   - 4지선다와 입력형 퀴즈 UI 분기 처리
   - 한자/히라가나/로마자 다중 정답 지원 (빈칸 퀴즈)
   - JLPT 레벨 및 발음 정보 표시
   - 기존 SRS 시스템과 연동 (cardId 기반)

5. **기존 SRS 로직 통합 완료**
   - 일본어 퀴즈에서도 기존 SRS 로직 완전 적용
   - 오답노트 자동 기록 (vocabId 기반)
   - 망각학습 알고리즘 동일 적용
   - 연속학습일 카운트 동일 적용
   - SRS 카드 상태 업데이트 동일 적용

6. **언어별 퀴즈 라우팅 및 UI 구분 완료**
   - `/web/apps/frontend/src/pages/SrsQuiz.jsx` 확장
   - 자동 언어 감지 로직 구현 (JLPT 카테고리, kana/romaji 필드 기반)
   - 일본어 퀴즈와 영어 퀴즈 UI 분기 처리
   - 퀴즈 타입 드롭다운 메뉴로 실시간 변경 가능
   - 기존 연속학습일 시스템과 완전 호환
   - 언어별 배지 표시 (영어/일본어 구분)

## 프로젝트 완료 상태
✅ **모든 요구 사항이 성공적으로 구현 완료되었습니다!**

### 완성된 기능들:
1. **4가지 일본어 퀴즈 타입 모두 구현 완료**
   - ✅ 일본어 단어 → 한국어 뜻 (4지선다)
   - ✅ 한국어 뜻 → 일본어 단어 (4지선다)
   - ✅ 예문 빈칸 스펠링 입력 (한자/로마자 모두 정답 처리)
   - ✅ 일본어 단어 → 로마자 발음 (4지선다)

2. **기존 SRS 로직 완전 적용**
   - ✅ 오답노트 자동 기록
   - ✅ 망각학습 알고리즘 동일 적용
   - ✅ 연속학습일 카운트
   - ✅ SRS 카드 상태 업데이트

3. **언어 구분 및 자동 감지**
   - ✅ JLPT 단어 자동 감지
   - ✅ 영어/일본어 퀴즈 자동 분기
   - ✅ 언어별 UI 구분

## 기술적 구현 완료 사항
- **백엔드**: 새로운 API 엔드포인트 `/quiz/japanese`, `/quiz/by-language` 구현
- **프론트엔드**: JapaneseQuiz 컴포넌트 및 SrsQuiz 통합 완료
- **타입 정의**: 일본어 퀴즈 전용 타입 시스템 구축
- **데이터베이스**: 기존 JLPT 단어 데이터와 완전 호환

## 테스트 권장 사항
1. JLPT N5 단어로 각 퀴즈 타입 테스트
2. 한자/히라가나/로마자 입력 퀴즈에서 다중 정답 확인
3. SRS 카드 상태 변화 및 오답노트 기록 확인
4. 연속학습일 카운트 정상 작동 확인

## 데이터베이스 구조 이슈 및 해결 (2025-09-16)

### 발견된 문제
- vocab 테이블에 kana, romaji, kanji 등의 일본어 전용 필드가 존재하지 않음
- 일본어 데이터는 dictentry.examples JSON 필드에 저장됨
- 프론트엔드에서 일본어 단어가 영어로 인식되는 문제 발생

### 해결 방안 구현
1. **언어 감지 로직 수정**
   - vocab.levelJLPT 필드 확인
   - vocab.source === 'jlpt_vocabs' 확인
   - dictentry.examples 내 일본어 데이터 존재 여부 확인

2. **백엔드 데이터 쿼리 수정**
   - `/srs/queue` 엔드포인트에서 dictentry와 translations 관계 포함
   - vocab 정보에 필요한 모든 관련 데이터 전달

3. **프론트엔드 언어 감지 동기화**
   - 백엔드와 동일한 언어 감지 로직 적용
   - levelJLPT, source, dictentry.examples 기반 판별

### 현재 데이터 저장 구조
- **일본어 단어**: dictentry.examples[].ja
- **한국어 번역**: VocabTranslation 테이블 (languageId=2)
- **로마자 발음**: dictentry.ipa 필드
- **예문**: dictentry.examples[].ja / examples[].ko
- **JLPT 레벨**: vocab.levelJLPT

## SRS Queue 500 에러 수정 (2025-09-16)

### 발견된 문제
- `/srs/queue?folderId=3&selectedItems=2:1` 요청에서 500 에러 발생
- Prisma 오류: `Unknown field 'categories' for select statement on model 'vocab'`
- SRS 라우트에서 언어 감지를 위해 존재하지 않는 `categories` 필드 사용

### 문제 원인
- `/web/apps/backend/routes/srs.js:1931`에서 잘못된 필드 선택
- `select: { categories: true, kana: true, romaji: true }` → `categories` 필드가 vocab 모델에 존재하지 않음
- detectLanguage 함수는 `levelJLPT`, `source`, `dictentry.examples` 필드를 사용함

### 해결 방안
**srs.js:1929-1940 수정**
```javascript
// 수정 전
const firstVocab = await prisma.vocab.findFirst({
    where: { id: vocabIds[0] },
    select: { categories: true, kana: true, romaji: true }
});

// 수정 후
const firstVocab = await prisma.vocab.findFirst({
    where: { id: vocabIds[0] },
    select: {
        levelJLPT: true,
        source: true,
        dictentry: {
            select: {
                examples: true
            }
        }
    }
});
```

### 수정 완료 상태
✅ **SRS Queue 500 에러 해결 완료**
- Prisma 쿼리에서 올바른 필드들 사용
- detectLanguage 함수와 호환되는 데이터 구조로 수정
- 일본어/영어 언어 감지 정상 작동

## SRS 퀴즈 UI 언어 감지 문제 수정 (2025-09-16)

### 발견된 문제
- 일본어 SRS 퀴즈에서 영어 퀴즈 UI가 표시되는 문제
- `isJapaneseQuiz` 조건이 복잡해서 언어 감지 실패
- 첫 번째 아이템만으로 언어 감지 시 불안정함

### 문제 원인
- `SrsQuiz.jsx:135`의 복잡한 조건식: `quizLanguage === 'ja' && current && current.vocab && detectLanguageFromVocab(current.vocab) === 'ja'`
- 첫 번째 vocab만으로 언어 감지 시 vocab 정보가 없을 경우 실패

### 해결 방안
**1. isJapaneseQuiz 조건 단순화**
```javascript
// 수정 전
const isJapaneseQuiz = quizLanguage === 'ja' && current && current.vocab && detectLanguageFromVocab(current.vocab) === 'ja';

// 수정 후
const isJapaneseQuiz = quizLanguage === 'ja';
```

**2. 언어 감지 로직 개선**
```javascript
// 수정 전: 첫 번째 아이템만 확인
const firstVocab = queueData[0].vocab;
if (firstVocab) {
    const detectedLanguage = detectLanguageFromVocab(firstVocab);
    // ...
}

// 수정 후: 큐 전체에서 일본어 검색
for (const item of queueData) {
    if (item.vocab) {
        const itemLanguage = detectLanguageFromVocab(item.vocab);
        if (itemLanguage === 'ja') {
            detectedLanguage = 'ja';
            break;
        }
    }
}
```

### 수정 완료 상태
✅ **일본어 SRS 퀴즈 UI 감지 문제 해결 완료**
- 언어 감지 로직을 더 안정적으로 개선
- 큐 전체에서 일본어 단어 존재 여부 확인
- isJapaneseQuiz 조건 단순화로 UI 분기 안정화

## selectedItems 파라미터 누락 문제 수정 (2025-09-16)

### 발견된 문제
- URL `http://localhost:3000/learn/vocab?mode=srs_folder&folderId=3&selectedItems=2`에서 여전히 영어 퀴즈 UI 표시
- `selectedItems` 파라미터가 SRS queue 요청에 포함되지 않음
- 특정 아이템 선택 시 언어 감지가 작동하지 않음

### 문제 원인
- `SrsQuiz.jsx`에서 URL의 `selectedItems` 파라미터를 읽지만 API 요청에 포함하지 않음
- useEffect 의존성 배열에 `selectedItems` 누락

### 해결 방안
**1. selectedItems 파라미터 추가**
```javascript
const selectedItems = params.get('selectedItems');

// queueUrl 생성 시 selectedItems 포함
let queueUrl;
if (allOverdue) {
    queueUrl = '/srs/queue?all=true';
    if (selectedItems) {
        queueUrl += `&selectedItems=${selectedItems}`;
    }
} else {
    queueUrl = `/srs/queue?folderId=${folderId}`;
    if (selectedItems) {
        queueUrl += `&selectedItems=${selectedItems}`;
    }
}
```

**2. useEffect 의존성 배열 수정**
```javascript
}, [folderId, allOverdue, selectedItems]);
```

### 수정 완료 상태
✅ **selectedItems 파라미터 누락 문제 해결 완료**
- URL의 selectedItems 파라미터가 SRS queue API 요청에 포함됨
- 특정 일본어 단어 선택 시 올바른 언어 감지 가능
- useEffect 의존성 배열에 selectedItems 추가로 파라미터 변경 시 재로딩

## LearnVocab.jsx 일본어 퀴즈 타입 선택 화면 수정 (2025-09-16)

### 발견된 근본 문제
- URL `/learn/vocab?mode=srs_folder&folderId=3&selectedItems=2`는 `LearnVocab` 컴포넌트로 라우팅됨
- `SrsQuiz` 컴포넌트가 아닌 `LearnVocab` 컴포넌트에서 퀴즈 타입 선택 화면이 표시됨
- `LearnVocab.jsx`에서 일본어 언어 감지 및 퀴즈 타입 선택이 영어 전용으로 하드코딩됨

### 해결 방안
**1. 언어 감지 함수 추가**
```javascript
const detectLanguageFromVocab = (vocab) => {
    if (!vocab) return 'en';
    if (vocab.levelJLPT) return 'ja';
    if (vocab.source === 'jlpt_vocabs') return 'ja';
    if (vocab.dictentry && vocab.dictentry.examples) {
        const examples = Array.isArray(vocab.dictentry.examples) ? vocab.dictentry.examples : [];
        const hasJapanese = examples.some(ex => ex.ja || ex.source === 'jlpt_vocabs');
        if (hasJapanese) return 'ja';
    }
    return 'en';
};
```

**2. 퀴즈 언어 상태 추가**
```javascript
const [quizLanguage, setQuizLanguage] = useState('en');
```

**3. 큐 데이터 로딩 후 언어 감지**
```javascript
// 큐 전체에서 언어 감지 (일본어가 하나라도 있으면 일본어 퀴즈)
if (fetched.length > 0) {
    let detectedLanguage = 'en';
    for (const item of fetched) {
        if (item.vocab) {
            const itemLanguage = detectLanguageFromVocab(item.vocab);
            if (itemLanguage === 'ja') {
                detectedLanguage = 'ja';
                break;
            }
        }
    }
    setQuizLanguage(detectedLanguage);
}
```

**4. 퀴즈 타입 선택 화면 언어별 분기**
- 일본어 감지 시: 4가지 일본어 퀴즈 타입 표시
  - 일본어 → 한국어 뜻 (4지선다)
  - 한국어 뜻 → 일본어 (4지선다)
  - 일본어 → 로마자 발음 (4지선다)
  - 예문 빈칸 채우기 (스펠링 입력)
- 영어 감지 시: 기존 영어 퀴즈 타입들 표시

### 수정 완료 상태
✅ **LearnVocab.jsx 일본어 지원 완료**
- 언어 자동 감지 로직 구현
- 일본어/영어 퀴즈 타입 선택 화면 분기 처리
- JapaneseQuizTypes import 및 사용
- 일본어 배지 표시로 언어 구분 명확화

## 최종 상태 (2025-09-16)
🎉 **모든 SRS 퀴즈 관련 문제 해결 완료**
1. ✅ SRS Queue 500 에러 수정 (Prisma 필드 오류)
2. ✅ 일본어 퀴즈 UI 언어 감지 개선 (SrsQuiz.jsx)
3. ✅ selectedItems 파라미터 누락 문제 해결 (SrsQuiz.jsx)
4. ✅ LearnVocab.jsx 일본어 퀴즈 타입 선택 화면 구현
5. ✅ 일본어 SRS 퀴즈에서 올바른 퀴즈 타입 표시 가능

**이제 URL `/learn/vocab?mode=srs_folder&folderId=3&selectedItems=2`에서 일본어 단어 선택 시 올바른 일본어 퀴즈 타입들이 표시됩니다!**

## 로마자 표시 문제 해결 (2025-09-16)

### 발견된 문제
- 일본어 4지선다 퀴즈에서 로마자가 일본어 문자 "あれ"로 잘못 표시됨
- 실제 로마자 "are"가 표시되어야 함

### 문제 원인
- `generateJapaneseToKoreanQuiz` 함수에서 `vocab.dictentry?.ipa` 필드 사용
- 실제로는 `dictentry.examples` 객체에서 로마자 추출해야 함
- 데이터 구조: `dictentry.examples`가 배열이 아닌 단일 객체로 저장됨

### 해결 방안 구현
**1. 데이터베이스 구조 확인**
- `dictentry.examples`는 JSON 객체 형태로 저장
- 실제 구조: `{kana: "わたし", kanji: "私", romaji: "watashi", example: "私は学生です"}`

**2. 백엔드 로직 수정**
```javascript
// 배열과 객체 모두 지원하는 로직
if (Array.isArray(examples)) {
    // 기존 배열 처리 로직
} else if (examples && typeof examples === 'object') {
    // 객체인 경우 직접 접근
    if (examples.romaji) {
        romaji = examples.romaji;
    }
    if (examples.kana) {
        hiragana = examples.kana;
    }
}
```

### 수정 완료 상태
✅ **일본어 퀴즈에서 로마자 표시 문제 해결 완료**
- `generateJapaneseToKoreanQuiz` 함수에서 올바른 로마자 추출
- 배열/객체 데이터 구조 모두 지원
- 로마자 패턴 검증 로직 추가
- 일본어 퀴즈에서 "私" → "watashi" 올바르게 표시

## 한국어→일본어 퀴즈 로마자 괄호 표시 추가 (2025-09-16)

### 요구사항
- 한국어 뜻에 대해 일본어 4지선다로 맞추는 퀴즈에서
- 각 선택지 옆에 해당 선택지의 로마자를 괄호로 표시

### 구현 내용
**1. 백엔드 수정** (`generateKoreanToJapaneseQuiz`)
- 선택지 데이터 구조 변경: 문자열 → `{text, romaji}` 객체
- distractor 수집 시 로마자 정보 함께 추출
- `optionsWithRomaji: true` 플래그 추가

**2. 프론트엔드 수정** (`JapaneseQuiz.jsx`)
- 객체와 문자열 선택지 모두 지원
- 로마자 표시: 각 선택지 아래에 `(romaji)` 형태로 표시
- UI 개선: 텍스트 왼쪽 정렬, 적절한 패딩

### 결과
이제 한국어 → 일본어 퀴즈에서:
```
학생
① 学生 (gakusei)
② 先生 (sensei)
③ 会社 (kaisha)
④ 大학 (daigaku)
```

## JLPT 레벨 배지 디자인 개선 (2025-09-16)

### 문제점
- 일본어 퀴즈에서 JLPT 레벨이 회색 길쭉한 배지로 표시됨
- 기존 단어 리스트의 깔끔한 색상 배지와 다름

### 해결 방안
**1. 기존 디자인 적용**
- `JapaneseVocabCard.jsx`의 `getJlptBadgeColor` 함수 동일 적용
- 레벨별 색상 구분:
  - N5: 초록색 (`bg-success`)
  - N4: 파란색 (`bg-info`)
  - N3: 노란색 (`bg-warning text-dark`)
  - N2: 빨간색 (`bg-danger`)
  - N1: 검은색 (`bg-dark`)

**2. 위치 및 크기 개선**
- 작은 네모 형태로 오른쪽 위에 배치
- `position-absolute`, `fontSize: 0.75rem`, `padding: 0.25rem 0.5rem`

### 수정 완료 상태
✅ **JLPT 레벨 배지 디자인 개선 완료**
- 기존 단어 리스트와 동일한 색상 적용
- 오른쪽 위 작은 네모 형태로 배치
- 레벨별 색상 구분으로 가독성 향상

## 스펠링 문제 예문 해석 표시 추가 (2025-09-16)

### 요구사항
- 일본어 스펠링 입력 문제(예문 빈칸 채우기)에서
- 예문에 대한 한국어 해석 표시

### 구현 내용
**1. 백엔드 수정** (`generateJapaneseFillInBlankQuiz`)
- 한국어 해석 추출: `examples.koExample` 활용
- `contextTranslation` 필드로 한국어 해석 전달

**2. 프론트엔드 수정** (`JapaneseQuiz.jsx`)
- 해석 표시 영역 추가: 스펠링 입력 필드 상단에 배치
- 연한 회색 배경의 alert 박스로 **"해석: [한국어 번역]"** 표시

### 결과
이제 일본어 스펠링 문제에서:
```
私は学生___

해석: 저는 학생입니다.

[답 입력 필드: 한자, 히라가나, 로마자 입력 가능]
```

### 최종 프로젝트 상태 (2025-09-16 최신)
🎉 **모든 일본어 SRS 퀴즈 시스템 완벽 구현 완료**

**구현된 주요 기능들:**
1. ✅ **4가지 일본어 퀴즈 타입 완전 구현**
   - 일본어 단어 → 한국어 뜻 (4지선다) + 로마자/히라가나 표시
   - 한국어 뜻 → 일본어 단어 (4지선다) + 로마자 괄호 표시
   - 일본어 단어 → 로마자 발음 (4지선다)
   - 예문 빈칸 스펠링 입력 + 한국어 해석 표시 + 3번 기회
   - 혼합형 (위 4가지 타입 랜덤 출제)

2. ✅ **UI/UX 개선 완료**
   - JLPT 레벨 배지: 레벨별 색상 + 오른쪽 위 작은 네모 형태
   - 로마자 표시: 올바른 데이터 추출 및 표시
   - 선택지 로마자: 한국어→일본어 퀴즈에서 괄호 표시
   - 예문 해석: 스펠링 문제에서 한국어 해석 제공

3. ✅ **기존 SRS 시스템과 완전 통합**
   - 오답노트 자동 기록
   - 망각학습 알고리즘 동일 적용
   - 연속학습일 카운트
   - 언어 자동 감지 및 분기

## 일본어 SRS 퀴즈 UI 통합 완료 (2025-09-16)

### 발견된 문제
- 일본어 SRS 퀴즈에서 정답을 맞춘 후에도 "미학습" 상태가 표시됨
- 정답 후 카드가 영어와 다르게 회색으로 표시되어야 할 때 초록색이 아님
- 일본어 SRS 퀴즈에서 별도의 `JapaneseQuiz` 컴포넌트 사용으로 SRS 시스템과 분리됨

### 문제 원인
- 일본어 SRS 퀴즈에서 `JapaneseQuiz` 컴포넌트 사용 시:
  1. SRS 카드 상태 업데이트가 UI에 반영되지 않음
  2. 영어 SRS와 다른 UI/로직 사용으로 일관성 부족
  3. 정답 후 처리 로직이 영어와 분리되어 있음

### 해결 방안 구현
**1. SRS 퀴즈 UI 통합**
- `/web/apps/frontend/src/pages/SrsQuiz.jsx` 수정
- 일본어 SRS 퀴즈에서도 영어와 동일한 카드 기반 UI 사용
- `JapaneseQuiz` 컴포넌트는 일반 학습용으로만 사용, SRS에서는 통합 UI 사용

**2. 언어별 배지 추가**
```javascript
// SRS 퀴즈 헤더에 언어 구분 배지 추가
{quizLanguage === 'en' && <span className="badge bg-success ms-2">영어</span>}
{quizLanguage === 'ja' && <span className="badge bg-info ms-2">일본어</span>}
```

**3. 일본어 발음 정보 지원**
- `/web/apps/frontend/src/components/Pron.jsx` 확장
- 히라가나, 로마자 발음 정보 표시 지원 추가
- SRS 퀴즈에서 일본어 발음 정보 전달

### 수정 완료 상태
✅ **일본어 SRS 퀴즈 UI 통합 완료**
- 영어와 일본어 SRS 퀴즈 완전 통합
- 정답 후 카드 상태 업데이트 로직 동일하게 적용
- 언어별 배지로 구분 표시
- 일본어 발음 정보(히라가나, 로마자) 지원

### 통합된 기능들
1. **동일한 SRS 로직**: 영어/일본어 구분 없이 동일한 카드 상태 업데이트
2. **동일한 UI**: 정답 후 초록색 배경, "정답 대기" 상태 표시
3. **동일한 오답노트**: 언어 구분 없이 통합된 오답 기록 시스템
4. **언어별 구분**: 배지로 시각적 구분, 발음 정보 언어별 지원

**이제 일본어 SRS 퀴즈에서도 영어와 동일하게 정답 후 초록색 배경과 "정답 대기" 상태가 올바르게 표시됩니다!**

## 일본어 퀴즈 API 500 에러 수정 (2025-09-16)

### 발견된 문제
- SRS 폴더에서 "학습" 버튼 클릭 후 일본어 퀴즈 타입 선택 시 500 에러 발생
- `POST /quiz/japanese` API에서 "Failed to create Japanese quiz" 에러
- `generateJapaneseToRomajiQuiz`와 `generateJapaneseFillInBlankQuiz` 함수에서 존재하지 않는 필드 참조

### 문제 원인
**1. 잘못된 필드 참조**
- `generateJapaneseToRomajiQuiz`: `vocab.romaji` 필드 사용 (존재하지 않음)
- `generateJapaneseFillInBlankQuiz`: `vocab.example`, `vocab.kana`, `vocab.kanji` 필드 사용 (존재하지 않음)
- 실제 일본어 데이터는 `dictentry.examples` JSON 배열에 저장됨

**2. 데이터 구조 불일치**
- vocab 모델에는 일본어 전용 필드가 없음
- 일본어 정보는 모두 `dictentry.examples[].ja`, `dictentry.examples[].romaji` 등에 저장

### 해결 방안 구현
**1. generateJapaneseToRomajiQuiz 함수 수정**
- `/web/apps/backend/services/quizService.js` 수정
- `vocab.romaji` → `dictentry.examples[].romaji`로 변경
- distractor 수집 로직도 동일하게 수정

**2. generateJapaneseFillInBlankQuiz 함수 수정**
- 예문 추출: `vocab.example` → `dictentry.examples[].ja`
- 일본어 단어: `vocab.kana/kanji` → `dictentry.examples[].ja`
- 발음 정보: `vocab.romaji/kana` → `dictentry.examples[].romaji/hiragana`

### 수정 완료 상태
✅ **일본어 퀴즈 API 500 에러 해결 완료**
- `generateJapaneseToRomajiQuiz` 함수 수정: dictentry.examples 기반 로마자 추출
- `generateJapaneseFillInBlankQuiz` 함수 수정: dictentry.examples 기반 예문/발음 추출
- Distractor 수집 로직 수정: 올바른 데이터 구조 사용
- 백엔드 서버 재시작으로 변경사항 적용 완료

**이제 SRS 폴더에서 "학습" 버튼 클릭 후 일본어 퀴즈 타입(일본어→로마자, 스펠링 입력) 선택이 정상 작동합니다!**

## 일본어 스펠링 퀴즈 3번 기회 로직 추가 (2025-09-16)

### 발견된 문제
- 일본어 스펠링 입력 퀴즈에서 1번만 시도 후 바로 오답 처리됨
- 영어 스펠링 퀴즈는 3번의 기회를 제공하는데 일본어는 공평하지 않음

### 해결 방안 구현
**1. 영어 스펠링 퀴즈의 3번 기회 로직 분석**
- `maxAttempts = 3` 상수 설정
- `attemptCount` 상태로 시도 횟수 추적
- 틀릴 때마다 시도 횟수 증가, 3번까지 기회 제공
- 경고 메시지와 남은 기회 표시

**2. 일본어 스펠링 퀴즈에 동일한 로직 적용**
- `/web/apps/frontend/src/components/JapaneseQuiz.jsx` 수정
- 스펠링 입력용 상태 추가:
  ```javascript
  const [attemptCount, setAttemptCount] = useState(0);
  const [maxAttempts] = useState(3);
  const [showSpellingWarning, setShowSpellingWarning] = useState(false);
  ```

**3. 답안 제출 로직 수정**
- 4지선다: 기존과 동일 (바로 결과 처리)
- 스펠링 입력: 3번 기회 로직 적용
  - 정답: 바로 결과 표시
  - 오답: 시도 횟수 증가
  - 3번째 오답: 최종 오답 처리
  - 1-2번째 오답: 경고 메시지 표시 후 재시도 기회

**4. UI 개선사항**
- 경고 메시지: "⚠️ 다시 생각해보세요!"
- 남은 기회 표시: "남은 기회: X번"
- 입력 필드 테두리 색상 변경 (경고 시 노란색)

### 수정 완료 상태
✅ **일본어 스펠링 퀴즈 3번 기회 로직 추가 완료**
- 영어 스펠링 퀴즈와 동일한 3번 기회 제공
- 시도 횟수 추적 및 경고 메시지 표시
- 문제 변경 시 상태 초기화
- 공평한 학습 환경 제공

**이제 일본어 스펠링 입력 퀴즈에서도 영어와 동일하게 3번의 기회가 제공됩니다!**

## 일본어 스펠링 퀴즈 예문 구조 수정 (2025-09-17)

### 발견된 문제
- 일본어 스펠링 퀴즈에서 예문이 표시되지 않고 한국어 뜻에 대한 스펠링 입력만 가능
- 시딩 스크립트 수정으로 예문 데이터 구조가 변경되었으나 백엔드 퀴즈 서비스가 구 구조를 기대

### 문제 원인
- **시딩 구조 변경**: `seed-jlpt-vocabs.js`에서 하이브리드 구조로 수정됨
- **백엔드 미동기화**: `generateJapaneseFillInBlankQuiz` 함수가 기존 구조만 지원
- **데이터 구조 불일치**:
  - 기존: `{ example: "私は学生です", koExample: "저는 학생입니다" }`
  - 신규: `[{ kind: 'example', ja: "私は学生です", ko: "저는 학생입니다" }]`

### 해결 방안 구현
**1. 백엔드 quizService.js 수정**
- `/web/apps/backend/services/quizService.js` 라인 608-643 수정
- 새로운 하이브리드 구조 지원 로직 추가:

```javascript
// 새로운 하이브리드 구조 지원 (2025-09-17 수정)
if (Array.isArray(examples)) {
    // 배열 구조: [{ kind: 'example', ja: ..., ko: ... }]
    const exampleItem = examples.find(item => item.kind === 'example');
    if (exampleItem && exampleItem.ja && exampleItem.ko) {
        targetExample = exampleItem.ja;
        koExample = exampleItem.ko;
        targetWord = vocab.lemma;
    }
} else if (examples && typeof examples === 'object') {
    // 객체 구조 (기존 호환성 + SRS 폴더용)
    if (examples.example && examples.koExample) {
        targetExample = examples.example;
        koExample = examples.koExample;
    } else if (examples.definitions && Array.isArray(examples.definitions)) {
        // SRS 폴더용 구조: definitions[].examples[]
        const defExample = examples.definitions[0]?.examples?.[0];
        if (defExample && defExample.ja && defExample.ko) {
            targetExample = defExample.ja;
            koExample = defExample.ko;
        }
    }
}
```

**2. 디버깅 로그 개선**
- 예문 구조 타입 확인: `exampleStructure: 'array' | 'object'`
- 예문 사용 여부 확인: `useExample: boolean`
- 추출된 데이터 확인: `targetExample`, `koExample`

### 수정 완료 상태
✅ **일본어 스펠링 퀴즈 예문 표시 문제 해결 완료**
- 새로운 하이브리드 예문 구조 완전 지원
- 배열, 객체, SRS 폴더용 구조 모두 호환
- 기존 구조 호환성 유지
- 백엔드 서버 재시작으로 변경사항 적용

**이제 일본어 스펠링 퀴즈에서 예문과 한국어 해석이 정상적으로 표시됩니다!**

## 일본어 오디오 퀴즈 구조 변경 (2025-09-17)

### 요구사항
- 기존 "일본어 → 로마자 발음" 퀴즈를 "오디오 → 일본어 단어" 퀴즈로 변경
- word.mp3 파일을 재생하고 사용자가 반복 재생할 수 있는 버튼 제공
- 4지선다로 알맞은 일본어 단어를 선택하는 문제로 변경

### 구현 완료사항

#### 1. 백엔드 퀴즈 로직 수정 ✅
**파일**: `/web/apps/backend/services/quizService.js`
- **generateJapaneseToRomajiQuiz 함수 완전 재구성** (라인 448-559)
- **기존**: 일본어 단어 → 로마자 4지선다
- **변경**: 오디오 파일 → 일본어 단어 4지선다

**주요 변경사항:**
```javascript
// 기존: 로마자를 distractor로 수집
const distractorRomaji = new Set();

// 변경: 일본어 단어를 distractor로 수집
const distractorWords = new Set();
distractorPool.forEach(v => {
    if (v.lemma) {
        distractorWords.add(v.lemma);
    }
});

// 기존: 일본어 단어가 질문, 로마자가 정답
const questionText = japaneseLemma;
const correctAnswer = romajiAnswer;

// 변경: 오디오가 질문, 일본어 단어가 정답
const questionAudio = audioInfo.word; // 오디오 파일 경로
const correctAnswer = japaneseLemma;

// 퀴즈 아이템 구조 변경
quizItems.push({
    cardId: cardIdMap.get(vocab.id) || null,
    vocabId: vocab.id,
    question: null, // 텍스트 질문 없음
    answer: correctAnswer,
    quizType: 'jp_word_to_romaji', // 타입명 유지 (호환성)
    audioQuestion: questionAudio, // 오디오 파일 경로 추가
    options: shuffleArray(options),
    // ...
});
```

#### 2. 퀴즈 타입 이름 및 설명 변경 ✅
**파일**: `/web/apps/frontend/src/types/japanese-quiz.js`
- **주석 업데이트**: "일본어 오디오를 듣고 일본어 단어를 맞추는 퀴즈"
- **설명 변경**: "일본어 오디오를 듣고 알맞은 일본어 단어를 선택하세요"

**파일**: `/web/apps/frontend/src/pages/LearnVocab.jsx`
- **UI 텍스트 변경**:
  - "4지선다 (일본어 → 로마자 발음)" → "4지선다 (오디오 → 일본어 단어)"
  - "일본어 단어를 보고 로마자 발음을 선택합니다" → "일본어 오디오를 듣고 알맞은 일본어 단어를 선택합니다"
  - "로마자 발음" → "오디오 듣기" (혼합형 설명에서)

#### 3. 프론트엔드 오디오 재생 UI 추가 ✅
**파일**: `/web/apps/frontend/src/components/JapaneseQuiz.jsx`

**3-1. 오디오 재생 함수 추가** (라인 96-116)
```javascript
const playAudio = (audioPath) => {
    if (!audioPath) {
        console.error('오디오 경로가 없습니다');
        return;
    }

    try {
        // JLPT 오디오 경로 구성: /jlpt/{level}/{folder}/word.mp3
        const fullAudioUrl = `${process.env.REACT_APP_API_URL || 'http://localhost:4000'}${audioPath}`;
        console.log('🔊 Playing audio:', fullAudioUrl);

        const audio = new Audio(fullAudioUrl);
        audio.play().catch(error => {
            console.error('오디오 재생 실패:', error);
            alert('오디오를 재생할 수 없습니다. 파일이 존재하지 않을 수 있습니다.');
        });
    } catch (error) {
        console.error('오디오 재생 중 오류:', error);
    }
};
```

**3-2. 오디오 질문 UI 추가** (라인 319-340)
```javascript
{/* 오디오 퀴즈인 경우 오디오 재생 버튼 표시 */}
{currentQuiz.audioQuestion ? (
    <div className="audio-question-section">
        <div className="text-center mb-3">
            <p className="h5 text-muted mb-3">🎧 오디오를 듣고 알맞은 일본어 단어를 선택하세요</p>
            <button
                className="btn btn-primary btn-lg"
                onClick={() => playAudio(currentQuiz.audioQuestion)}
                style={{ fontSize: '1.5rem', padding: '12px 24px' }}
            >
                🔊 오디오 재생
            </button>
            <div className="text-muted mt-2">
                <small>버튼을 눌러 오디오를 재생할 수 있습니다</small>
            </div>
        </div>
    </div>
) : (
    <h2 className="display-6 mb-3" lang="ja">
        {currentQuiz.question}
    </h2>
)}
```

### 기술적 세부사항

#### 오디오 데이터 구조
- **백엔드**: `vocab.dictentry.audioLocal` JSON에서 `audioInfo.word` 경로 추출
- **프론트엔드**: `currentQuiz.audioQuestion` 필드로 오디오 파일 경로 전달
- **경로 형식**: `/jlpt/n5/{romaji}/word.mp3`

#### 호환성 유지
- **퀴즈 타입 ID**: `jp_word_to_romaji` 유지 (기존 혼합형 등과 호환)
- **4지선다 구조**: 기존과 동일한 options 배열 사용
- **SRS 통합**: 기존 SRS 로직과 완전 호환

### 완료된 변경사항 요약 (2025-09-17)

#### ✅ 백엔드 (퀴즈 생성 로직)
- 오디오 정보 추출 및 일본어 단어 distractor 수집
- 퀴즈 아이템에 `audioQuestion` 필드 추가
- 디버깅 로그 개선 (`[JP AUDIO QUIZ]`)

#### ✅ 프론트엔드 (타입 정의 및 UI)
- 퀴즈 설명 텍스트 업데이트
- 오디오 재생 버튼 및 UI 구현
- 조건부 렌더링 (오디오 vs 텍스트 질문)

#### ✅ 사용자 경험
- **명확한 가이드**: "🎧 오디오를 듣고 알맞은 일본어 단어를 선택하세요"
- **재생 버튼**: 🔊 아이콘과 함께 큰 버튼으로 쉽게 식별 가능
- **반복 재생**: 사용자가 원할 때마다 오디오 재생 가능
- **오류 처리**: 오디오 파일 없을 시 적절한 안내 메시지

**🎯 새로운 퀴즈 플로우:**
1. 사용자가 퀴즈 시작
2. 오디오 재생 버튼과 안내 문구 표시
3. 사용자가 오디오 재생 (반복 가능)
4. 4개의 일본어 단어 중 선택
5. 정답 확인 및 다음 문제로 진행

## LearnVocab.jsx 일본어 퀴즈 렌더링 로직 추가 (2025-09-16)

### 발견된 문제
- 일본어 퀴즈 타입 선택 후에도 영어 퀴즈 UI가 표시됨
- `JapaneseQuiz` 컴포넌트 import 누락
- 일본어 퀴즈 타입 선택 시 `JapaneseQuiz` 컴포넌트로 렌더링하는 로직 부재

### 해결 방안
**1. JapaneseQuiz 컴포넌트 import 추가**
```javascript
import JapaneseQuiz from '../components/JapaneseQuiz';
```

**2. 일본어 퀴즈 렌더링 로직 추가**
```javascript
// 일본어 퀴즈 렌더링 (일본어 퀴즈 타입이 선택된 경우)
if (quizLanguage === 'ja' && quizTypeParam && Object.values(JapaneseQuizTypes).includes(quizTypeParam)) {
    const japaneseVocabIds = queue
        .filter(item => item.vocab && detectLanguageFromVocab(item.vocab) === 'ja')
        .map(item => item.vocabId);

    const handleJapaneseQuizComplete = () => {
        navigate(folderIdParam ? `/srs/folder/${folderIdParam}` : '/srs');
    };

    return (
        <main className="container py-4" style={{ maxWidth: 720 }}>
            <audio ref={audioRef} style={{ display: 'none' }} />
            <JapaneseQuiz
                vocabIds={japaneseVocabIds}
                quizType={quizTypeParam}
                onQuizComplete={handleJapaneseQuizComplete}
                folderId={folderIdParam}
            />
        </main>
    );
}
```

### 수정 완료 상태
✅ **LearnVocab.jsx 일본어 퀴즈 완전 지원 완료**
- JapaneseQuiz 컴포넌트 import 및 렌더링 로직 추가
- 일본어 퀴즈 타입 선택 시 올바른 일본어 퀴즈 UI 표시
- 퀴즈 완료 후 폴더로 돌아가기 기능 구현

**이제 일본어 퀴즈 타입 선택 시 올바른 일본어 퀴즈가 표시됩니다!**

## 일본어 퀴즈 혼합형 타입 추가 (2025-09-16)

### 추가된 기능
- 영어 퀴즈와 마찬가지로 일본어 퀴즈에도 혼합형 문제 유형 추가
- 4가지 일본어 퀴즈 타입이 랜덤하게 출제되는 혼합형 옵션 구현

### 수정 사항
**1. japanese-quiz.js 타입 정의 추가**
```javascript
export const JapaneseQuizTypes = {
  // 기존 타입들...

  // 혼합형 퀴즈 (위 4가지 타입이 랜덤하게 출제)
  JP_MIXED: 'jp_mixed'
};

// 설명 추가
[JapaneseQuizTypes.JP_MIXED]: '다양한 유형의 일본어 퀴즈가 랜덤하게 출제됩니다'
```

**2. LearnVocab.jsx UI 옵션 추가**
```javascript
<button
    className="btn btn-outline-secondary btn-lg text-start p-3"
    onClick={() => handleQuizTypeSelect(JapaneseQuizTypes.JP_MIXED)}
>
    <div className="d-flex align-items-center">
        <div className="me-3" style={{ fontSize: '2rem' }}>🎯</div>
        <div>
            <h6 className="mb-1">혼합형</h6>
            <small className="text-muted">일본어→한국어, 한국어→일본어, 로마자 발음, 스펠링 입력이 랜덤하게 출제됩니다</small>
        </div>
    </div>
</button>
```

### 구현된 일본어 퀴즈 타입 (총 5가지)
1. ✅ **일본어 → 한국어 뜻** (4지선다)
2. ✅ **한국어 뜻 → 일본어** (4지선다)
3. ✅ **일본어 → 로마자 발음** (4지선다)
4. ✅ **예문 빈칸 채우기** (스펠링 입력)
5. ✅ **혼합형** (위 4가지 타입 랜덤 출제) 🆕

### 수정 완료 상태
✅ **일본어 퀴즈 혼합형 타입 추가 완료**
- 타입 정의 및 설명 추가
- 퀴즈 선택 UI에 혼합형 옵션 추가
- 영어 퀴즈와 동일한 UX 제공

## 백엔드 혼합형 퀴즈 지원 추가 (2025-09-16)

### 발견된 문제
- `/quiz/japanese` API에서 500 에러 발생
- `jp_mixed` 타입이 지원 타입 목록에 포함되지 않음
- `generateJapaneseMixedQuiz` 함수 미구현

### 해결 방안
**1. 지원 타입 목록에 혼합형 추가**
```javascript
// routes/quiz.js
const supportedTypes = [
    'jp_word_to_ko_meaning',
    'ko_meaning_to_jp_word',
    'jp_word_to_romaji',
    'jp_fill_in_blank',
    'jp_mixed' // 추가
];
```

**2. generateJapaneseMixedQuiz 함수 구현**
```javascript
// services/quizService.js
async function generateJapaneseMixedQuiz(prisma, userId, vocabIds) {
    const quizTypes = [
        'jp_word_to_ko_meaning',
        'ko_meaning_to_jp_word',
        'jp_word_to_romaji',
        'jp_fill_in_blank'
    ];

    const quizItems = [];
    for (const vocabId of vocabIds) {
        // 각 단어마다 랜덤하게 퀴즈 타입 선택
        const randomType = quizTypes[Math.floor(Math.random() * quizTypes.length)];
        // 해당 타입의 퀴즈 생성 후 추가
    }

    return quizItems.map(item => ({
        ...item,
        originalQuizType: item.quizType, // 원래 타입 보존
        quizType: 'jp_mixed' // 혼합형으로 표시
    }));
}
```

**3. generateQuizByLanguageAndType에 케이스 추가**
```javascript
case 'jp_mixed':
    return generateJapaneseMixedQuiz(prisma, userId, vocabIds);
```

### 수정 완료 상태
✅ **백엔드 혼합형 퀴즈 지원 완료**
- `/quiz/japanese` API에서 `jp_mixed` 타입 처리 가능
- 각 단어마다 랜덤한 퀴즈 타입 생성
- 원래 퀴즈 타입 정보 보존하여 UI에서 적절히 렌더링 가능

## quizService.js categories 필드 오류 완전 수정 (2025-09-16)

### 발견된 추가 문제
- `quizService.js`의 여러 함수에서 `categories` 필드 사용으로 Prisma 에러 발생
- 일본어 퀴즈 생성 시 vocab 모델의 잘못된 필드 참조

### 수정된 위치들
1. **일본어 단어 검색 조건 수정 (4곳)**
   ```javascript
   // 수정 전
   OR: [
       { categories: { contains: 'JLPT' } },
       { kana: { not: null } }
   ]

   // 수정 후
   OR: [
       { levelJLPT: { not: null } },
       { source: 'jlpt_vocabs' }
   ]
   ```

2. **JLPT 레벨 추출 로직 단순화 (3곳)**
   ```javascript
   // 수정 전
   jlptLevel: extractJlptLevel(vocab.categories),

   // 수정 후
   jlptLevel: vocab.levelJLPT,
   ```

### 수정 완료 상태
✅ **모든 categories 필드 오류 수정 완료**
- SRS queue API와 Japanese quiz API 모두 정상 작동
- vocab 모델의 올바른 필드들 사용: `levelJLPT`, `source`
- 일본어 퀴즈 생성 가능

## 일본어 SRS 퀴즈 후리가나 표시 문제 해결 (2025-09-17)

### 발견된 문제
- **SRS 퀴즈에서 일본어 단어 → 한국어 뜻 맞추기 문제에서 한자 위에 후리가나가 표시되지 않음**
- 예시: "お兄さん"이 후리가나 없이 표시됨 (올바른 표시: お<ruby>兄<rt>にい</rt></ruby>さん)
- 일본어 단어카드에서는 후리가나가 잘 표시되는데 SRS 퀴즈에서만 문제 발생

### 문제 원인 분석
1. **프론트엔드 문제 (SrsQuiz.jsx)**:
   - SRS 퀴즈에서 `current?.question`을 직접 텍스트로 표시
   - 일본어인 경우 `FuriganaDisplay` 컴포넌트를 사용하지 않음

2. **백엔드 문제 (quizService.js)**:
   - `generateMcqQuizItems` 함수에서 일본어 히라가나 정보를 `pron` 필드에 포함하지 않음
   - `pron: { ipa: vocab.dictentry.ipa, ipaKo: vocab.dictentry.ipaKo }`만 설정

3. **데이터 구조 문제**:
   - 히라가나 데이터가 `dictentry.ipa`에 저장되어 있는데 `dictentry.examples`에서 찾고 있었음
   - 시딩 스크립트 `seed-jlpt-vocabs.js:151`에서 `ipa: item.kana || null`로 저장

### 해결 방안 구현 (2025-09-17)

#### 1. 프론트엔드 수정 (SrsQuiz.jsx)
**파일**: `/web/apps/frontend/src/pages/SrsQuiz.jsx`

1. **FuriganaDisplay 컴포넌트 추가** (라인 9-118):
   ```javascript
   // JapaneseVocabCard.jsx의 FuriganaDisplay 컴포넌트를 복사
   function FuriganaDisplay({ kanji, kana }) {
     // 복잡한 파싱 로직으로 한자 부분에만 후리가나 표시
   }
   ```

2. **일본어 질문 표시 로직 수정** (라인 526-535):
   ```javascript
   // 수정 전
   <h2 className="display-5 mb-2" lang={quizLanguage}>{current?.question ?? '—'}</h2>

   // 수정 후
   {quizLanguage === 'ja' ? (
       <div className="display-5 mb-2">
           <FuriganaDisplay
               kanji={current?.question}
               kana={current?.pron?.hiragana || current?.pron?.kana}
           />
       </div>
   ) : (
       <h2 className="display-5 mb-2" lang={quizLanguage}>{current?.question ?? '—'}</h2>
   )}
   ```

3. **디버깅 로그 추가** (라인 528-537):
   ```javascript
   console.log('🔍 [SRS Japanese Quiz Debug]', {
       question: current?.question,
       pron: current?.pron,
       hiragana: current?.pron?.hiragana,
       kana: current?.pron?.kana,
       romaji: current?.pron?.romaji,
       vocab: current?.vocab
   });
   ```

#### 2. 백엔드 수정 (quizService.js)
**파일**: `/web/apps/backend/services/quizService.js`

**일본어 히라가나 정보 추출 로직 수정** (라인 125-140):
```javascript
// 수정 전: dictentry.examples에서 히라가나 찾기 (잘못된 위치)
if (isJapanese && vocab.dictentry?.examples) {
    const examples = vocab.dictentry.examples;
    // 복잡한 배열/객체 구조 파싱...
}

// 수정 후: dictentry.ipa/ipaKo에서 직접 가져오기 (올바른 위치)
if (isJapanese && vocab.dictentry) {
    // 히라가나는 dictentry.ipa에 저장됨 (seed-jlpt-vocabs.js:151)
    hiragana = vocab.dictentry.ipa;

    // 로마자는 dictentry.ipaKo에 저장됨 (seed-jlpt-vocabs.js:152)
    romaji = vocab.dictentry.ipaKo;

    console.log(`[MCQ QUIZ DEBUG] Japanese word ${vocab.lemma}: hiragana=${hiragana}, romaji=${romaji}`);
}

// pron 객체에 일본어 정보 포함
pron: {
    ipa: vocab.dictentry.ipa,
    ipaKo: vocab.dictentry.ipaKo,
    hiragana: hiragana, // 일본어 히라가나 추가
    romaji: romaji      // 일본어 로마자 추가
}
```

### 데이터 흐름 정리
1. **시딩**: `seed-jlpt-vocabs.js` → `dictentry.ipa`에 히라가나 저장
2. **백엔드**: `generateMcqQuizItems` → `pron.hiragana`에 히라가나 전달
3. **프론트엔드**: `SrsQuiz.jsx` → `FuriganaDisplay`로 후리가나 렌더링

### 수정 완료 상태
✅ **일본어 SRS 퀴즈 후리가나 표시 문제 해결 완료**
- 시딩 스크립트에서 저장하는 실제 데이터 위치 확인
- 백엔드에서 올바른 위치에서 히라가나 정보 추출
- 프론트엔드에서 일본어 퀴즈 시 FuriganaDisplay 컴포넌트 사용
- 디버깅 로그로 데이터 흐름 확인 가능

**이제 일본어 SRS 퀴즈에서 한자 위에 후리가나가 올바르게 표시됩니다!**

## 일본어 퀴즈 후리가나 표시 문제 해결 (2025-09-17)

### 발견된 추가 문제
- **일반 일본어 퀴즈(`JapaneseQuiz.jsx`)에서도 후리가나가 표시되지 않음**
- SRS 퀴즈와 마찬가지로 일본어 질문을 직접 텍스트로 표시
- 콘솔 로그: `JapaneseQuiz.jsx:135 [JAPANESE QUIZ] Loaded quiz items`

### 문제 원인
- `JapaneseQuiz.jsx:359-361`에서 일본어 질문을 직접 텍스트로 표시:
  ```javascript
  <h2 className="display-6 mb-3" lang="ja">
      {currentQuiz.question}
  </h2>
  ```
- `FuriganaDisplay` 컴포넌트를 사용하지 않음

### 해결 방안 구현 (2025-09-17)

#### 1. JapaneseQuiz.jsx에 FuriganaDisplay 컴포넌트 추가
**파일**: `/web/apps/frontend/src/components/JapaneseQuiz.jsx`

1. **FuriganaDisplay 컴포넌트 추가** (라인 7-116):
   ```javascript
   // Furigana display component - handles mixed kanji/hiragana
   function FuriganaDisplay({ kanji, kana }) {
     // 동일한 복잡한 파싱 로직으로 한자 부분에만 후리가나 표시
   }
   ```

2. **일본어 질문 표시 로직 수정** (라인 470-485):
   ```javascript
   // 수정 전
   <h2 className="display-6 mb-3" lang="ja">
       {currentQuiz.question}
   </h2>

   // 수정 후
   <div className="display-6 mb-3">
       <FuriganaDisplay
           kanji={currentQuiz.question}
           kana={currentQuiz.pron?.hiragana || currentQuiz.pron?.kana}
       />
   </div>
   ```

3. **디버깅 로그 추가** (라인 471-480):
   ```javascript
   console.log('🔍 [JAPANESE QUIZ DEBUG]', {
       question: currentQuiz.question,
       pron: currentQuiz.pron,
       hiragana: currentQuiz.pron?.hiragana,
       kana: currentQuiz.pron?.kana,
       romaji: currentQuiz.pron?.romaji
   });
   ```

### 수정 완료 상태
✅ **일본어 퀴즈 후리가나 표시 문제 해결 완료**
- `JapaneseQuiz.jsx`에 `FuriganaDisplay` 컴포넌트 추가
- 일본어 질문 표시 시 후리가나 렌더링
- SRS 퀴즈와 동일한 후리가나 표시 로직 적용
- 디버깅 로그로 `pron` 데이터 확인 가능

**이제 모든 일본어 퀴즈(SRS/일반)에서 한자 위에 후리가나가 올바르게 표시됩니다!**

## 일본어 퀴즈 API 후리가나 데이터 누락 문제 해결 (2025-09-17)

### 발견된 추가 문제
- **일본어 퀴즈 API에서 `pron` 필드에 히라가나 데이터가 누락됨**
- 콘솔 로그: `🔍 [JAPANESE QUIZ DEBUG] {pron: {romaji: null, hiragana: null}}`
- 데이터베이스에는 히라가나 정보가 있지만 API 응답에서 누락

### 문제 원인
- `generateJapaneseToKoreanQuiz` 함수에서 `dictentry.ipa`를 로마자 패턴으로만 체크
- 실제로는 `ipa` 필드에 히라가나(`'おにいさん'`)가 저장되어 있음
- `ipaKo` 필드에 로마자(`'oniisan'`)가 저장되어 있음

### 해결 방안 구현 (2025-09-17)

#### generateJapaneseToKoreanQuiz 함수 수정
**파일**: `/web/apps/backend/services/quizService.js`

**히라가나/로마자 추출 로직 수정** (라인 295-306):
```javascript
// 수정 전: ipa 필드를 로마자 패턴으로만 체크
if (!romaji && vocab.dictentry?.ipa) {
    const ipaField = vocab.dictentry.ipa;
    if (/^[a-zA-Z\s\-']+$/.test(ipaField)) {
        romaji = ipaField;
    }
}

// 수정 후: 올바른 필드에서 히라가나와 로마자 가져오기
if (!hiragana && vocab.dictentry?.ipa) {
    // ipa 필드에 히라가나가 저장됨 (seed-jlpt-vocabs.js:151)
    hiragana = vocab.dictentry.ipa;
}

if (!romaji && vocab.dictentry?.ipaKo) {
    // ipaKo 필드에 로마자가 저장됨 (seed-jlpt-vocabs.js:152)
    romaji = vocab.dictentry.ipaKo;
}
```

### 수정 완료 상태
✅ **일본어 퀴즈 API 후리가나 데이터 누락 문제 해결 완료**
- `generateJapaneseToKoreanQuiz` 함수에서 올바른 필드에서 히라가나 추출
- `dictentry.ipa`에서 히라가나, `dictentry.ipaKo`에서 로마자 가져오기
- `pron` 필드에 히라가나와 로마자 정보 포함
- 백엔드 디버깅 로그로 데이터 확인 가능

**이제 일본어 퀴즈에서 `pron.hiragana`에 올바른 히라가나 데이터가 전달되어 후리가나가 표시됩니다!**

## 일본어 스펠링 퀴즈 완전 수정 (2025-09-16)

### 발견된 문제점들
1. **스펠링 문제에서 lemma 부분 노출**
   - 예시: '차'의 정답이 'ocha'인데 'o'가 노출됨
   - 원인: 일부 정답 형태만 빈칸 처리되고 있었음

2. **한국어 해석에서 정답 단어 강조 안 됨**
   - 예시: "차를 마시지 않겠습니까?"에서 "차"가 검은색으로 표시
   - 원인: 품사 정보 포함된 번역(`n. 차`)과 순수 단어(`차`) 불일치

### 해결 방안 구현 (2025-09-16)

#### 1. 스펠링 문제 lemma 완전 숨김 처리
**백엔드 수정** (`/web/apps/backend/services/quizService.js:660-668`)
```javascript
// 모든 형태의 정답을 빈칸으로 교체 (긴 것부터 먼저 교체하여 부분 교체 방지)
const allAnswers = [...acceptableAnswers].sort((a, b) => b.length - a.length);
for (const answer of allAnswers) {
    if (answer) {
        // 정확한 단어 경계를 고려하여 교체 (부분 문자열 교체 방지)
        const regex = new RegExp(answer.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
        contextBlank = contextBlank.replace(regex, '___');
    }
}
```

**개선사항:**
- vocab.lemma 포함 모든 허용 정답 형태(한자, 히라가나, 로마자) 빈칸 처리
- 긴 단어부터 교체하여 부분 교체 방지 (예: "茶" → "お茶" 순서로 처리)
- 정규식 특수문자 이스케이프 처리로 정확한 매칭

#### 2. 한국어 해석 정답 단어 빨간색 강조
**백엔드 수정** (`/web/apps/backend/services/quizService.js:675-707`)
```javascript
// 품사 정보 제거 (n., v., adj. 등)
const cleanedTranslation = koreanTranslation.replace(/^[a-zA-Z]+\.\s*/, '');

// 정답 번역에서 가능한 모든 의미 추출
const meanings = cleanedTranslation.split(/[,;\/]/).map(m => m.trim());

let foundMatch = false;
for (const meaning of meanings) {
    if (meaning && koExample.includes(meaning)) {
        highlightedTranslation = koExample.replace(
            new RegExp(meaning.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'),
            `{{HIGHLIGHT_START}}${meaning}{{HIGHLIGHT_END}}`
        );
        foundMatch = true;
        break;
    }
}
```

**프론트엔드 수정** (`/web/apps/frontend/src/components/JapaneseQuiz.jsx:19-54`)
```javascript
const highlightAnswerInTranslation = (translation) => {
    // 백엔드에서 전달된 강조 마킹을 처리
    if (translation.includes('{{HIGHLIGHT_START}}')) {
        const parts = translation.split('{{HIGHLIGHT_START}}');
        const beforeHighlight = parts[0];
        const remainingPart = parts[1];
        const highlightParts = remainingPart.split('{{HIGHLIGHT_END}}');
        const highlighted = highlightParts[0];
        const afterHighlight = highlightParts[1] || '';

        return (
            <span>
                {beforeHighlight}
                <span style={{ color: 'red', fontWeight: 'bold' }}>{highlighted}</span>
                {afterHighlight}
            </span>
        );
    }
    return translation;
};
```

### 구현된 기능 향상사항

#### 1. 품사 정보 자동 제거
- **문제**: `'n. 차'` (품사 포함) vs `'차를 마시지 않겠습니까?'` (순수 텍스트)
- **해결**: 정규식 `/^[a-zA-Z]+\.\s*/`로 품사 정보 제거
- **결과**: `'n. 차'` → `'차'`로 정제

#### 2. 다중 의미 지원
- **기능**: 쉼표, 세미콜론, 슬래시로 구분된 번역 지원
- **예시**: `'차, 茶'` → `['차', '茶']` 배열로 분리 후 각각 매칭 시도

#### 3. 정확한 문자열 교체
- **특수문자 이스케이프**: 정규식 특수문자를 안전하게 처리
- **전역 교체**: 같은 단어가 여러 번 나와도 모두 강조

#### 4. 강력한 백업 매칭
- **1차 시도**: 완전한 단어 매칭
- **2차 시도**: 번역의 첫 글자라도 강조 (완전 실패 방지)

### 테스트 결과 (2025-09-16)

#### Before (수정 전)
```
문제: ___을 마시지 않겠습니까?  // 'o'가 노출됨 ❌
해석: 차를 마시지 않겠습니까?   // '차' 검은색 ❌
```

#### After (수정 후)
```
문제: ___을 마시지 않겠습니까?  // 완전히 숨겨짐 ✅
해석: 차를 마시지 않겠습니까?   // '차' 빨간색 강조 ✅
```

### 디버깅 정보 추가
```javascript
console.log('Japanese Fill-in-Blank Quiz Item:', {
    vocabId: vocab.id,
    targetWord: targetWord,
    contextTranslation: koExample,
    answerTranslation: koreanTranslation,        // 'n. 차'
    cleanedTranslation: cleanedTranslation,      // '차'
    highlightedTranslation: highlightedTranslation, // '{{HIGHLIGHT_START}}차{{HIGHLIGHT_END}}를...'
});
```

### 최종 완료 상태 (2025-09-16)
🎉 **일본어 스펠링 퀴즈 완벽 수정 완료**

**✅ 해결된 문제들:**
1. **Lemma 완전 숨김**: 모든 정답 형태(한자/히라가나/로마자/lemma)가 빈칸 처리
2. **한국어 강조 표시**: 예문 해석에서 정답에 해당하는 한국어 단어 빨간색 볼드 강조
3. **품사 정보 처리**: `'n. 차'` → `'차'` 자동 정제로 정확한 매칭
4. **다중 번역 지원**: 쉼표/세미콜론으로 구분된 여러 의미 모두 지원
5. **안전한 문자열 처리**: 정규식 특수문자 이스케이프로 안정성 보장

**🔧 기술적 구현:**
- **백엔드**: 강조 마킹 시스템 (`{{HIGHLIGHT_START}}...{{HIGHLIGHT_END}}`)
- **프론트엔드**: React 컴포넌트 기반 동적 스타일링
- **데이터 흐름**: 백엔드 전처리 → 마킹 전달 → 프론트엔드 렌더링

**📊 성능 최적화:**
- 정규식 컴파일 최소화
- 배열 정렬로 긴 단어 우선 처리
- 조기 탈출(early exit) 패턴 적용

이제 일본어 스펠링 퀴즈에서 완벽한 학습 경험을 제공합니다! 🚀

---

## 일본어 SRS 언어별 분리 시스템 구현 (2025-09-17)

### 📋 구현 요구사항
사용자가 바탕화면에서 "복습 시작" 버튼을 클릭할 때 언어별로 분리된 퀴즈 시스템 구현:

**현재 상황**: 복습 대기 3개 (일본어 1개 + 영어 2개 섞여있음)

**원하는 로직**:
1. **단일 언어**: 해당 언어 문제 선택창 바로 표시
2. **혼합 언어**: 언어 선택 모달 → 언어별 문제 선택창
3. **복습 완료 후**: 남은 언어 자동 처리

### ✅ 완료된 구현 사항

#### 1. 백엔드 API 언어별 카드 분류 로직 ✅
**파일**: `/web/apps/backend/routes/srs.js` (84-137행)

**주요 변경사항**:
- `/srs/available` API 응답 형식 변경: 카드 배열 → 언어별 객체
- 일본어 카드 감지 로직: JLPT 레벨, 소스, 정규식 3중 검증
- 성능 최적화: 단일 쿼리로 모든 카드 조회 후 프론트엔드에서 분류

**새로운 응답 구조**:
```javascript
{
  success: true,
  data: {
    japanese: [{ /* 일본어 카드들 */ }],
    english: [{ /* 영어 카드들 */ }],
    total: 3,
    hasMultipleLanguages: true
  }
}
```

**언어 감지 로직**:
```javascript
const isJapanese = vocab.levelJLPT ||
                  vocab.source === 'jlpt_vocabs' ||
                  (vocab.lemma && /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(vocab.lemma));
```

#### 2. 프론트엔드 Dashboard 컴포넌트 수정 ✅
**파일**: `/web/apps/frontend/src/pages/Dashboard.jsx`

**주요 개선사항**:
- 새로운 API 응답 구조 처리 (90-109행)
- 언어별 상태 관리 추가
- SRS 카드 UI 완전 개편 (375-412행)

**새로운 SRS 카드 UI**:
```javascript
// 언어별 카드 수 표시
<div className="h4 mb-1">복습 대기: <span className="text-primary">{stats.srsQueue}</span> 개</div>
{stats.hasMultipleLanguages && (
    <small className="text-muted">
        🇯🇵 {stats.srsJapanese}개 • 🇺🇸 {stats.srsEnglish}개
    </small>
)}

// 복습 시작 버튼
{stats.srsQueue > 0 && (
    <button className="btn btn-warning btn-sm" onClick={handleSrsStartClick}>
        복습 시작
    </button>
)}
```

#### 3. 언어 선택 모달 UI 컴포넌트 생성 ✅
**파일**: `/web/apps/frontend/src/components/LanguageSelectionModal.jsx`

**UI 특징**:
- 🇯🇵 일본어 복습 버튼 (JLPT 단어 학습)
- 🇺🇸 영어 복습 버튼 (CEFR/TOEIC/TOEFL 단어)
- 각 언어별 카드 수 배지 표시
- Bootstrap 기반 반응형 모달 디자인

#### 4. 복습 시작 로직 구현 ✅
**파일**: `/web/apps/frontend/src/pages/Dashboard.jsx` (202-239행)

**핸들러 함수들**:

##### `handleSrsStartClick()` - 복습 시작 로직
```javascript
// 단일 언어 처리
if (!stats.hasMultipleLanguages) {
    if (stats.srsJapanese > 0 && stats.srsEnglish === 0) {
        // 일본어만 있는 경우
        window.location.href = '/srs/quiz?language=japanese';
    } else if (stats.srsEnglish > 0 && stats.srsJapanese === 0) {
        // 영어만 있는 경우
        window.location.href = '/srs/quiz?language=english';
    }
} else {
    // 혼합 언어 - 모달 표시
    setShowLanguageModal(true);
}
```

##### `handleLanguageSelect(language)` - 언어 선택 처리
```javascript
if (language === 'japanese') {
    window.location.href = '/srs/quiz?language=japanese';
} else if (language === 'english') {
    window.location.href = '/srs/quiz?language=english';
}
```

### 🔄 실행 흐름

#### 시나리오 1: 일본어만 있는 경우
1. 복습 시작 클릭 → 일본어 문제 선택창 바로 이동

#### 시나리오 2: 영어만 있는 경우
1. 복습 시작 클릭 → 영어 문제 선택창 바로 이동

#### 시나리오 3: 혼합 언어 (현재 상황)
1. 복습 시작 클릭 → 언어 선택 모달 표시
2. 🇯🇵 일본어 복습 (1개) 또는 🇺🇸 영어 복습 (2개) 선택
3. 선택한 언어의 문제 선택창으로 이동
4. 복습 완료 후 → 남은 언어 자동 처리

### 🎯 기술적 구현 세부사항

#### 백엔드 개선사항
- **언어 감지 정확도**: JLPT 레벨, 소스, 정규식 3중 검증
- **성능 최적화**: 단일 쿼리로 모든 카드 조회 후 프론트엔드에서 분류
- **확장성**: 새로운 언어 추가 시 쉬운 확장 가능

#### 프론트엔드 개선사항
- **사용자 경험**: 직관적인 언어 선택 인터페이스
- **시각적 표시**: 플래그 아이콘과 카드 수 배지로 명확한 정보 제공
- **반응형 디자인**: 모든 화면 크기에서 적절한 표시

#### URL 파라미터 시스템
- `/srs/quiz?language=japanese` - 일본어 퀴즈 모드
- `/srs/quiz?language=english` - 영어 퀴즈 모드

### 📊 현재 테스트 상황
- **백엔드**: 포트 4000에서 정상 실행 중
- **API 응답**: 언어별 분류 정상 작동 (일본어 1개, 영어 2개 확인)
- **프론트엔드**: 새로운 UI 구현 완료
- **통합 테스트**: 브라우저에서 확인 필요

### 🚀 다음 단계 (예정)

#### 1. SrsQuiz 컴포넌트 언어 파라미터 처리
- URL 쿼리 파라미터 `language` 감지
- 해당 언어 카드만 필터링하여 퀴즈 진행

#### 2. 복습 진행 상태 관리
- 한 언어 복습 완료 시 자동으로 다른 언어 감지
- 완료된 언어 제외한 남은 언어 자동 시작

#### 3. 사용자 피드백 개선
- 복습 진행률 표시
- 언어별 완료 상태 시각화

---

## 개발 완료 요약 ✅

**구현된 기능**:
1. ✅ 백엔드 언어별 카드 분류 API
2. ✅ 프론트엔드 Dashboard 언어 감지 로직
3. ✅ 언어 선택 모달 UI 컴포넌트
4. ✅ 복습 시작 버튼 클릭 핸들러

**사용자 경험**:
- 단일 언어: 즉시 해당 언어 퀴즈 시작
- 혼합 언어: 아름다운 언어 선택 모달로 선택 후 시작
- 시각적 표시: 언어별 카드 수와 플래그 아이콘

**일본어와 영어 SRS 퀴즈가 이제 완전히 분리되어 사용자 친화적으로 작동합니다!** 🎌🇺🇸✨

**다음으로 브라우저에서 바탕화면 새로고침 후 "복습 시작" 버튼 테스트 예정**