// bundle-analyzer.js - Î≤àÎì§ ÌÅ¨Í∏∞ Î∂ÑÏÑù Ïä§ÌÅ¨Î¶ΩÌä∏
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');

// Î≤àÎì§ ÌÅ¨Í∏∞ Î∂ÑÏÑù ÌÅ¥ÎûòÏä§
class BundleAnalyzer {
  constructor() {
    this.projectRoot = process.cwd();
    this.bundleDir = path.join(this.projectRoot, 'bundle-analysis');
    this.setupDirectories();
  }

  setupDirectories() {
    if (!fs.existsSync(this.bundleDir)) {
      fs.mkdirSync(this.bundleDir, { recursive: true });
    }
  }

  // Android Î≤àÎì§ ÏÉùÏÑ± Î∞è Î∂ÑÏÑù
  async analyzeAndroidBundle() {
    console.log('üì¶ Android Î≤àÎì§ Î∂ÑÏÑù Ï§ë...');
    
    try {
      // Android Î¶¥Î¶¨Ïä§ Î≤àÎì§ ÏÉùÏÑ±
      const bundlePath = path.join(this.bundleDir, 'android-release.bundle');
      const mapPath = path.join(this.bundleDir, 'android-release.bundle.map');
      
      execSync(`npx react-native bundle \\
        --platform android \\
        --dev false \\
        --entry-file index.js \\
        --bundle-output ${bundlePath} \\
        --sourcemap-output ${mapPath} \\
        --assets-dest ${this.bundleDir}/android-assets`, 
        { stdio: 'inherit' }
      );

      // Î≤àÎì§ ÌÅ¨Í∏∞ Ï∏°Ï†ï
      const stats = fs.statSync(bundlePath);
      const sizeInMB = (stats.size / (1024 * 1024)).toFixed(2);
      
      console.log(`‚úÖ Android Î≤àÎì§ ÌÅ¨Í∏∞: ${sizeInMB}MB`);
      
      // ÏÉÅÏÑ∏ Î∂ÑÏÑù
      await this.generateBundleReport(bundlePath, 'android');
      
      return {
        platform: 'android',
        size: sizeInMB,
        path: bundlePath
      };
    } catch (error) {
      console.error('‚ùå Android Î≤àÎì§ Î∂ÑÏÑù Ïã§Ìå®:', error.message);
      throw error;
    }
  }

  // iOS Î≤àÎì§ ÏÉùÏÑ± Î∞è Î∂ÑÏÑù  
  async analyzeIosBundle() {
    console.log('üì¶ iOS Î≤àÎì§ Î∂ÑÏÑù Ï§ë...');
    
    try {
      // iOS Î¶¥Î¶¨Ïä§ Î≤àÎì§ ÏÉùÏÑ±
      const bundlePath = path.join(this.bundleDir, 'ios-release.bundle');
      const mapPath = path.join(this.bundleDir, 'ios-release.bundle.map');
      
      execSync(`npx react-native bundle \\
        --platform ios \\
        --dev false \\
        --entry-file index.js \\
        --bundle-output ${bundlePath} \\
        --sourcemap-output ${mapPath} \\
        --assets-dest ${this.bundleDir}/ios-assets`, 
        { stdio: 'inherit' }
      );

      // Î≤àÎì§ ÌÅ¨Í∏∞ Ï∏°Ï†ï
      const stats = fs.statSync(bundlePath);
      const sizeInMB = (stats.size / (1024 * 1024)).toFixed(2);
      
      console.log(`‚úÖ iOS Î≤àÎì§ ÌÅ¨Í∏∞: ${sizeInMB}MB`);
      
      // ÏÉÅÏÑ∏ Î∂ÑÏÑù
      await this.generateBundleReport(bundlePath, 'ios');
      
      return {
        platform: 'ios',
        size: sizeInMB,
        path: bundlePath
      };
    } catch (error) {
      console.error('‚ùå iOS Î≤àÎì§ Î∂ÑÏÑù Ïã§Ìå®:', error.message);
      throw error;
    }
  }

  // Î≤àÎì§ ÏÉÅÏÑ∏ Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
  async generateBundleReport(bundlePath, platform) {
    console.log(`üìä ${platform} Î≤àÎì§ ÏÉÅÏÑ∏ Î∂ÑÏÑù ÏÉùÏÑ± Ï§ë...`);
    
    try {
      // Metro visualizer Ïã§Ìñâ
      const reportPath = path.join(this.bundleDir, `${platform}-bundle-report.html`);
      
      // Î≤àÎì§ ÎÇ¥Ïö© Î∂ÑÏÑùÏùÑ ÏúÑÌïú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
      const bundleContent = fs.readFileSync(bundlePath, 'utf8');
      const modules = this.extractModules(bundleContent);
      
      // HTML Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
      const reportHtml = this.generateHtmlReport(modules, platform);
      fs.writeFileSync(reportPath, reportHtml);
      
      console.log(`üìã Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± ÏôÑÎ£å: ${reportPath}`);
      
      // ÌÅ∞ Î™®ÎìàÎì§ ÏãùÎ≥Ñ
      const largeModules = modules
        .filter(m => m.size > 50000) // 50KB Ïù¥ÏÉÅ
        .sort((a, b) => b.size - a.size)
        .slice(0, 10);
      
      if (largeModules.length > 0) {
        console.log('üîç ÌÅ∞ Î™®ÎìàÎì§:');
        largeModules.forEach(module => {
          const sizeKB = (module.size / 1024).toFixed(1);
          console.log(`  - ${module.name}: ${sizeKB}KB`);
        });
      }
      
    } catch (error) {
      console.error('‚ùå Î≤àÎì§ Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± Ïã§Ìå®:', error.message);
    }
  }

  // Î≤àÎì§ÏóêÏÑú Î™®Îìà Ï†ïÎ≥¥ Ï∂îÏ∂ú
  extractModules(bundleContent) {
    const modules = [];
    
    // Í∞ÑÎã®Ìïú Î™®Îìà ÌååÏã± (Ïã§Ï†úÎ°úÎäî Îçî Î≥µÏû°Ìïú ÌååÏã±Ïù¥ ÌïÑÏöî)
    const moduleRegex = /__d\(function\([\s\S]*?\),(\d+),\[([^\]]*)\],"([^"]+)"/g;
    let match;
    
    while ((match = moduleRegex.exec(bundleContent)) !== null) {
      const moduleCode = match[0];
      const moduleId = match[1];
      const dependencies = match[2];
      const moduleName = match[3];
      
      modules.push({
        id: moduleId,
        name: moduleName,
        size: moduleCode.length,
        dependencies: dependencies.split(',').filter(dep => dep.trim())
      });
    }
    
    return modules.sort((a, b) => b.size - a.size);
  }

  // HTML Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
  generateHtmlReport(modules, platform) {
    const totalSize = modules.reduce((sum, m) => sum + m.size, 0);
    
    return `
<!DOCTYPE html>
<html>
<head>
    <title>${platform.toUpperCase()} Bundle Analysis</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background: #4A90E2; color: white; padding: 20px; border-radius: 8px; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin: 20px 0; }
        .stat-card { background: #f5f5f5; padding: 16px; border-radius: 8px; text-align: center; }
        .modules-table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        .modules-table th, .modules-table td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        .modules-table th { background: #4A90E2; color: white; }
        .size-bar { height: 20px; background: #e0e0e0; border-radius: 10px; overflow: hidden; }
        .size-fill { height: 100%; background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722); }
    </style>
</head>
<body>
    <div class="header">
        <h1>${platform.toUpperCase()} Bundle Analysis Report</h1>
        <p>Generated on ${new Date().toLocaleString()}</p>
    </div>
    
    <div class="stats">
        <div class="stat-card">
            <h3>Total Bundle Size</h3>
            <p>${(totalSize / (1024 * 1024)).toFixed(2)} MB</p>
        </div>
        <div class="stat-card">
            <h3>Total Modules</h3>
            <p>${modules.length}</p>
        </div>
        <div class="stat-card">
            <h3>Largest Module</h3>
            <p>${modules[0] ? (modules[0].size / 1024).toFixed(1) + 'KB' : 'N/A'}</p>
        </div>
        <div class="stat-card">
            <h3>Average Module Size</h3>
            <p>${modules.length ? (totalSize / modules.length / 1024).toFixed(1) + 'KB' : 'N/A'}</p>
        </div>
    </div>
    
    <h2>Top Modules by Size</h2>
    <table class="modules-table">
        <thead>
            <tr>
                <th>Module Name</th>
                <th>Size (KB)</th>
                <th>Size Visualization</th>
                <th>Dependencies</th>
            </tr>
        </thead>
        <tbody>
            ${modules.slice(0, 20).map(module => {
              const sizeKB = (module.size / 1024).toFixed(1);
              const percentage = (module.size / totalSize * 100).toFixed(1);
              
              return `
                <tr>
                    <td>${module.name}</td>
                    <td>${sizeKB}</td>
                    <td>
                        <div class="size-bar">
                            <div class="size-fill" style="width: ${percentage}%"></div>
                        </div>
                        ${percentage}%
                    </td>
                    <td>${module.dependencies.length}</td>
                </tr>
              `;
            }).join('')}
        </tbody>
    </table>
</body>
</html>
    `;
  }

  // ÏùòÏ°¥ÏÑ± Î∂ÑÏÑù
  async analyzeDependencies() {
    console.log('üîç ÏùòÏ°¥ÏÑ± Î∂ÑÏÑù Ï§ë...');
    
    try {
      // package.json ÏùΩÍ∏∞
      const packagePath = path.join(this.projectRoot, 'package.json');
      const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
      
      const dependencies = {
        ...packageJson.dependencies,
        ...packageJson.devDependencies
      };
      
      // Í∞Å ÏùòÏ°¥ÏÑ±Ïùò ÌÅ¨Í∏∞ Ï∂îÏ†ï
      const dependencyAnalysis = [];
      
      for (const [name, version] of Object.entries(dependencies)) {
        try {
          const modulePath = path.join(this.projectRoot, 'node_modules', name);
          const modulePackagePath = path.join(modulePath, 'package.json');
          
          if (fs.existsSync(modulePackagePath)) {
            const modulePackage = JSON.parse(fs.readFileSync(modulePackagePath, 'utf8'));
            const moduleSize = this.getDirectorySize(modulePath);
            
            dependencyAnalysis.push({
              name,
              version: version,
              actualVersion: modulePackage.version,
              size: moduleSize,
              description: modulePackage.description || ''
            });
          }
        } catch (error) {
          console.warn(`‚ö†Ô∏è ${name} Î∂ÑÏÑù Ïã§Ìå®:`, error.message);
        }
      }
      
      // ÌÅ¨Í∏∞ ÏàúÏúºÎ°ú Ï†ïÎ†¨
      dependencyAnalysis.sort((a, b) => b.size - a.size);
      
      // ÌÅ∞ ÏùòÏ°¥ÏÑ±Îì§ Ï∂úÎ†•
      console.log('üì¶ ÌÅ∞ ÏùòÏ°¥ÏÑ±Îì§ (ÏÉÅÏúÑ 10Í∞ú):');
      dependencyAnalysis.slice(0, 10).forEach((dep, index) => {
        const sizeMB = (dep.size / (1024 * 1024)).toFixed(2);
        console.log(`  ${index + 1}. ${dep.name}: ${sizeMB}MB`);
      });
      
      // Î¶¨Ìè¨Ìä∏ Ï†ÄÏû•
      const reportPath = path.join(this.bundleDir, 'dependencies-analysis.json');
      fs.writeFileSync(reportPath, JSON.stringify(dependencyAnalysis, null, 2));
      
      return dependencyAnalysis;
      
    } catch (error) {
      console.error('‚ùå ÏùòÏ°¥ÏÑ± Î∂ÑÏÑù Ïã§Ìå®:', error.message);
      throw error;
    }
  }

  // ÎîîÎ†âÌÜ†Î¶¨ ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
  getDirectorySize(dirPath) {
    let totalSize = 0;
    
    try {
      const items = fs.readdirSync(dirPath, { withFileTypes: true });
      
      for (const item of items) {
        const itemPath = path.join(dirPath, item.name);
        
        if (item.isDirectory()) {
          totalSize += this.getDirectorySize(itemPath);
        } else if (item.isFile()) {
          const stats = fs.statSync(itemPath);
          totalSize += stats.size;
        }
      }
    } catch (error) {
      // Ï†ëÍ∑º Í∂åÌïú ÏóÜÎäî ÎîîÎ†âÌÜ†Î¶¨ Îì±ÏùÄ Î¨¥Ïãú
    }
    
    return totalSize;
  }

  // Ï†ÑÏ≤¥ Î∂ÑÏÑù Ïã§Ìñâ
  async runFullAnalysis() {
    console.log('üöÄ Ï†ÑÏ≤¥ Î≤àÎì§ Î∂ÑÏÑù ÏãúÏûë...\n');
    
    try {
      // ÏùòÏ°¥ÏÑ± Î∂ÑÏÑù
      const dependencies = await this.analyzeDependencies();
      
      // Android Î≤àÎì§ Î∂ÑÏÑù
      const androidResult = await this.analyzeAndroidBundle();
      
      // iOS Î≤àÎì§ Î∂ÑÏÑù  
      const iosResult = await this.analyzeIosBundle();
      
      // Ï¢ÖÌï© Î¶¨Ìè¨Ìä∏
      const summary = {
        timestamp: new Date().toISOString(),
        bundles: [androidResult, iosResult],
        dependencies: dependencies.slice(0, 20),
        recommendations: this.generateRecommendations(dependencies, [androidResult, iosResult])
      };
      
      // Ï¢ÖÌï© Î¶¨Ìè¨Ìä∏ Ï†ÄÏû•
      const summaryPath = path.join(this.bundleDir, 'bundle-analysis-summary.json');
      fs.writeFileSync(summaryPath, JSON.stringify(summary, null, 2));
      
      console.log('\\nüìä Î∂ÑÏÑù ÏôÑÎ£å!');
      console.log(`üìÅ Í≤∞Í≥º Ï†ÄÏû•: ${this.bundleDir}`);
      
      return summary;
      
    } catch (error) {
      console.error('‚ùå Î≤àÎì§ Î∂ÑÏÑù Ïã§Ìå®:', error.message);
      throw error;
    }
  }

  // ÏµúÏ†ÅÌôî Í∂åÏû•ÏÇ¨Ìï≠ ÏÉùÏÑ±
  generateRecommendations(dependencies, bundles) {
    const recommendations = [];
    
    // ÌÅ∞ ÏùòÏ°¥ÏÑ± ÏãùÎ≥Ñ
    const largeDependencies = dependencies.filter(dep => dep.size > 5 * 1024 * 1024); // 5MB Ïù¥ÏÉÅ
    
    if (largeDependencies.length > 0) {
      recommendations.push({
        type: 'large_dependencies',
        title: 'ÌÅ∞ ÏùòÏ°¥ÏÑ± ÏµúÏ†ÅÌôî',
        description: 'Îã§Ïùå ÏùòÏ°¥ÏÑ±Îì§Ïù¥ Î≤àÎì§ ÌÅ¨Í∏∞Î•º ÌÅ¨Í≤å Ï¶ùÍ∞ÄÏãúÌÇµÎãàÎã§:',
        items: largeDependencies.map(dep => `${dep.name} (${(dep.size / 1024 / 1024).toFixed(2)}MB)`)
      });
    }
    
    // Î≤àÎì§ ÌÅ¨Í∏∞ Í≤ΩÍ≥†
    const largeBundles = bundles.filter(bundle => parseFloat(bundle.size) > 10); // 10MB Ïù¥ÏÉÅ
    
    if (largeBundles.length > 0) {
      recommendations.push({
        type: 'large_bundle',
        title: 'Î≤àÎì§ ÌÅ¨Í∏∞ ÏµúÏ†ÅÌôî ÌïÑÏöî',
        description: 'Î≤àÎì§ ÌÅ¨Í∏∞Í∞Ä Í∂åÏû• ÌÅ¨Í∏∞Î•º Ï¥àÍ≥ºÌï©ÎãàÎã§:',
        items: largeBundles.map(bundle => `${bundle.platform}: ${bundle.size}MB`)
      });
    }
    
    // ÏùºÎ∞òÏ†ÅÏù∏ ÏµúÏ†ÅÌôî Í∂åÏû•ÏÇ¨Ìï≠
    recommendations.push({
      type: 'general_optimization',
      title: 'ÏùºÎ∞òÏ†ÅÏù∏ ÏµúÏ†ÅÌôî Î∞©Î≤ï',
      description: 'Î≤àÎì§ ÌÅ¨Í∏∞Î•º Ï§ÑÏù¥Í∏∞ ÏúÑÌïú Í∂åÏû•ÏÇ¨Ìï≠:',
      items: [
        'Tree shaking ÌôúÏÑ±Ìôî',
        'Code splitting Ï†ÅÏö©',
        'Unused imports Ï†úÍ±∞',
        'ProGuard/R8 ÏÑ§Ï†ï ÏµúÏ†ÅÌôî',
        'Ïù¥ÎØ∏ÏßÄ ÏïïÏ∂ï Î∞è WebP ÏÇ¨Ïö©',
        'Metro bundler ÏÑ§Ï†ï ÏµúÏ†ÅÌôî'
      ]
    });
    
    return recommendations;
  }
}

// CLI Ïã§Ìñâ
if (require.main === module) {
  const analyzer = new BundleAnalyzer();
  analyzer.runFullAnalysis().catch(console.error);
}

module.exports = BundleAnalyzer;