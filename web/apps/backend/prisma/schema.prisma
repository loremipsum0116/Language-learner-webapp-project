generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "foreignKeys"
}

model category {
  id          Int         @id @default(autoincrement())
  userId      Int
  name        String
  createdAt   DateTime    @default(now())
  kind        String      @default("wordbook")
  nextAlarmAt DateTime?
  alarmActive Boolean     @default(true)
  remindEvery Int?
  user        user        @relation(fields: [userId], references: [id], onDelete: Cascade, map: "Category_userId_fkey")
  srscard     srscard[]
  uservocab   uservocab[]

  @@unique([userId, name], map: "Category_userId_name_key")
}

model dailystudystat {
  id           Int      @id @default(autoincrement())
  userId       Int
  date         DateTime
  srsSolved    Int      @default(0)
  autoLearned  Int      @default(0)
  wrongDueNext Int      @default(0)
  createdAt    DateTime @default(now())
  user         user     @relation(fields: [userId], references: [id], onDelete: Cascade, map: "DailyStudyStat_userId_fkey")

  @@unique([userId, date], map: "DailyStudyStat_userId_date_key")
}

model dictentry {
  id          Int       @id @default(autoincrement())
  vocabId     Int       @unique(map: "DictEntry_vocabId_key")
  ipa         String?
  audioUrl    String?
  audioLocal  String?
  license     String?
  attribution String?
  sourceUrl   String?
  retrievedAt DateTime?
  examples    Json
  ipaKo       String?
  vocab       vocab     @relation(fields: [vocabId], references: [id], onDelete: Cascade, map: "DictEntry_vocabId_fkey")
}

model grammarexercise {
  id        Int    @id @default(autoincrement())
  topicId   String @unique(map: "GrammarExercise_topicId_key")
  topic     String
  levelCEFR String
  items     Json
}

model grammaritem {
  id       Int    @id @default(autoincrement())
  topic    String
  rule     String
  examples Json
}

model reading {
  id        Int    @id @default(autoincrement())
  title     String
  body      String @db.Text
  levelCEFR String
  glosses   Json
}

model sessionbatch {
  id        Int      @id @default(autoincrement())
  userId    Int
  createdAt DateTime @default(now())
  order     Int
  cards     Json
}

model srscard {
  id                Int             @id @default(autoincrement())
  userId            Int
  itemType          String
  itemId            Int
  stage             Int             @default(0)
  nextReviewAt      DateTime?
  categoryId        Int?
  correctTotal      Int             @default(0)
  wrongTotal        Int             @default(0)
  cohortDate        DateTime?
  isOverdue         Boolean         @default(false)
  overdueDeadline   DateTime?
  isFromWrongAnswer Boolean         @default(false)
  waitingUntil      DateTime?
  frozenUntil       DateTime?
  folderId          Int?
  isMastered        Boolean         @default(false)
  masterCycles      Int             @default(0)
  masteredAt        DateTime?
  overdueStartAt    DateTime?
  wrongStreakCount  Int             @default(0)
  lastReviewedAt    DateTime?
  isTodayStudy      Boolean         @default(false)
  todayFirstResult  Boolean?
  todayStudyDate    DateTime?
  category          category?       @relation(fields: [categoryId], references: [id], map: "SRSCard_categoryId_fkey")
  folder            srsfolder?      @relation(fields: [folderId], references: [id], onDelete: Cascade, map: "SRSCard_folderId_fkey")
  user              user            @relation(fields: [userId], references: [id], onDelete: Cascade, map: "SRSCard_userId_fkey")
  srsfolderitem     srsfolderitem[]

  @@unique([userId, itemType, itemId, folderId], map: "SRSCard_userId_itemType_itemId_folderId_key")
  @@index([categoryId], map: "SRSCard_categoryId_fkey")
  @@index([folderId], map: "SRSCard_folderId_fkey")
  @@index([userId, isMastered], map: "SRSCard_userId_isMastered_idx")
  @@index([userId, nextReviewAt], map: "SRSCard_userId_nextReviewAt_idx")
}

model srsfolder {
  id                  Int             @id @default(autoincrement())
  userId              Int
  parentId            Int?
  name                String
  createdDate         DateTime        @db.Date
  stage               Int             @default(0)
  nextReviewDate      DateTime?       @db.Date
  lastReviewedAt      DateTime?
  nextReviewAt        DateTime?
  alarmActive         Boolean         @default(true)
  nextAlarmAt         DateTime?
  completedAt         DateTime?
  cycleAnchorAt       DateTime        @default(now())
  kind                String          @default("manual")
  scheduledOffset     Int?
  autoCreated         Boolean         @default(false)
  originSessionId     Int?
  isCompleted         Boolean         @default(false)
  completedWordsCount Int             @default(0)
  completionCount     Int             @default(0)
  isMastered          Boolean         @default(false)
  date                DateTime        @default(now())
  createdAt           DateTime        @default(now())
  updatedAt           DateTime
  reminderMask        Int             @default(0)
  learningCurveType   String          @default("long")
  isFolderMastered    Boolean         @default(false)
  folderMasteredAt    DateTime?
  srscard             srscard[]
  user                user            @relation(fields: [userId], references: [id], onDelete: Cascade, map: "SrsFolder_userId_fkey")
  srsfolderitem       srsfolderitem[]
  uservocab           uservocab[]
  wronganswer         wronganswer[]

  @@index([nextAlarmAt], map: "SrsFolder_nextAlarmAt_idx")
  @@index([parentId], map: "SrsFolder_parentId_idx")
  @@index([userId, alarmActive, nextReviewAt], map: "SrsFolder_userId_alarmActive_nextReviewAt_idx")
}

model srsfolderitem {
  id             Int       @id @default(autoincrement())
  folderId       Int
  cardId         Int
  learned        Boolean   @default(false)
  wrongCount     Int       @default(0)
  lastReviewedAt DateTime?
  vocabId        Int?
  lastWrongAt    DateTime?
  srscard        srscard   @relation(fields: [cardId], references: [id], onDelete: Cascade, map: "SrsFolderItem_cardId_fkey")
  srsfolder      srsfolder @relation(fields: [folderId], references: [id], onDelete: Cascade, map: "SrsFolderItem_folderId_fkey")
  vocab          vocab?    @relation(fields: [vocabId], references: [id], onDelete: Cascade, map: "SrsFolderItem_vocabId_fkey")

  @@unique([folderId, cardId], map: "SrsFolderItem_folderId_cardId_key")
  @@unique([folderId, vocabId], map: "SrsFolderItem_folderId_vocabId_key")
  @@index([cardId], map: "SrsFolderItem_cardId_idx")
  @@index([folderId, learned], map: "SrsFolderItem_folderId_learned_idx")
  @@index([vocabId], map: "SrsFolderItem_vocabId_fkey")
}

model user {
  id               Int              @id @default(autoincrement())
  email            String           @unique(map: "User_email_key")
  passwordHash     String
  role             String           @default("USER")
  profile          Json?
  createdAt        DateTime         @default(now())
  lastStudiedAt    DateTime?
  streak           Int              @default(0)
  streakUpdatedAt  DateTime?
  dailyQuizCount   Int              @default(0)
  lastQuizDate     DateTime?
  hasOverdueCards  Boolean          @default(false)
  lastOverdueCheck DateTime?
  nextOverdueAlarm DateTime?
  personalizedSRS  Json?
  learningProfile  Json?
  cardReports      CardReport[]
  category         category[]
  dailystudystat   dailystudystat[]
  refreshToken     refreshToken[]
  srscard          srscard[]
  srsfolder        srsfolder[]
  studySessions    StudySession[]
  userLanguages    UserLanguage[]
  uservocab        uservocab[]
  wronganswer      wronganswer[]
}

model uservocab {
  id         Int        @id @default(autoincrement())
  userId     Int
  vocabId    Int
  createdAt  DateTime   @default(now())
  categoryId Int?
  folderId   Int?
  category   category?  @relation(fields: [categoryId], references: [id], map: "UserVocab_categoryId_fkey")
  folder     srsfolder? @relation(fields: [folderId], references: [id], onDelete: Cascade, map: "UserVocab_folderId_fkey")
  user       user       @relation(fields: [userId], references: [id], onDelete: Cascade, map: "UserVocab_userId_fkey")
  vocab      vocab      @relation(fields: [vocabId], references: [id], onDelete: Cascade, map: "UserVocab_vocabId_fkey")

  @@unique([userId, vocabId, folderId], map: "UserVocab_userId_vocabId_folderId_key")
  @@index([categoryId], map: "UserVocab_categoryId_fkey")
  @@index([folderId], map: "UserVocab_folderId_fkey")
  @@index([userId, categoryId], map: "UserVocab_userId_categoryId_idx")
  @@index([userId, folderId], map: "UserVocab_userId_folderId_idx")
  @@index([vocabId], map: "UserVocab_vocabId_fkey")
}

model Language {
  id            Int                @id @default(autoincrement())
  code          String             @unique
  name          String
  nativeName    String
  isActive      Boolean            @default(true)
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  audioSources  AudioSource[]
  userLanguages UserLanguage[]
  vocabs        vocab[]
  translations  VocabTranslation[]

  @@map("languages")
}

model vocab {
  id                Int                 @id @default(autoincrement())
  languageId        Int
  lemma             String
  pos               String
  plural            String?
  levelCEFR         String?
  levelJLPT         String?
  levelHSK          String?
  levelDELF         String?
  freq              Int?
  source            String?
  reports           CardReport[]
  dictentry         dictentry?
  srsfolderitem     srsfolderitem[]
  uservocab         uservocab[]
  language          Language            @relation(fields: [languageId], references: [id], onDelete: Cascade)
  vocabexamcategory vocabexamcategory[]
  translations      VocabTranslation[]
  wronganswer       wronganswer[]

  @@index([lemma], map: "Vocab_lemma_idx")
  @@index([source], map: "Vocab_source_idx")
  @@index([languageId], map: "Vocab_languageId_idx")
  @@index([languageId, levelCEFR], map: "Vocab_languageId_levelCEFR_idx")
}

model wronganswer {
  id                Int        @id @default(autoincrement())
  userId            Int
  vocabId           Int?
  wrongAt           DateTime   @default(now())
  reviewWindowStart DateTime
  reviewWindowEnd   DateTime
  reviewedAt        DateTime?
  isCompleted       Boolean    @default(false)
  attempts          Int        @default(0)
  folderId          Int?
  itemId            Int
  itemType          String     @default("vocab")
  wrongData         Json?
  folder            srsfolder? @relation(fields: [folderId], references: [id], onDelete: Cascade, map: "WrongAnswer_folderId_fkey")
  user              user       @relation(fields: [userId], references: [id], onDelete: Cascade, map: "WrongAnswer_userId_fkey")
  vocab             vocab?     @relation(fields: [vocabId], references: [id], onDelete: Cascade, map: "WrongAnswer_vocabId_fkey")

  @@unique([userId, itemType, itemId, folderId, wrongAt], map: "WrongAnswer_userId_itemType_itemId_folderId_wrongAt_key")
  @@index([reviewWindowStart, reviewWindowEnd], map: "WrongAnswer_reviewWindowStart_reviewWindowEnd_idx")
  @@index([userId, isCompleted], map: "WrongAnswer_userId_isCompleted_idx")
  @@index([userId, itemType], map: "WrongAnswer_userId_itemType_idx")
  @@index([vocabId], map: "WrongAnswer_vocabId_fkey")
  @@index([folderId], map: "WrongAnswer_folderId_fkey")
}

model examcategory {
  id                Int                 @id @default(autoincrement()) @map("id")
  name              String              @unique
  description       String?
  totalWords        Int                 @default(0)
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  vocabexamcategory vocabexamcategory[]

  @@map("exam_categories")
}

model vocabexamcategory {
  id             Int          @id @default(autoincrement())
  vocabId        Int
  examCategoryId Int
  priority       Int          @default(0)
  addedAt        DateTime     @default(now())
  examCategory   examcategory @relation(fields: [examCategoryId], references: [id], onDelete: Cascade)
  vocab          vocab        @relation(fields: [vocabId], references: [id], onDelete: Cascade)

  @@unique([vocabId, examCategoryId])
  @@index([examCategoryId])
  @@index([vocabId])
  @@map("vocab_exam_categories")
}

model readingRecord {
  id            Int      @id @default(autoincrement())
  userId        Int
  questionId    String
  level         String
  isCorrect     Boolean
  userAnswer    String
  correctAnswer String
  solvedAt      DateTime @default(now())

  @@unique([userId, questionId, level])
  @@index([userId, level])
  @@map("reading_records")
}

model listeningRecord {
  id            Int      @id @default(autoincrement())
  userId        Int
  questionId    String
  level         String
  isCorrect     Boolean
  userAnswer    String
  correctAnswer String
  solvedAt      DateTime @default(now())

  @@unique([userId, questionId, level])
  @@index([userId, level])
  @@map("listening_records")
}

model UserLanguage {
  id             Int       @id @default(autoincrement())
  userId         Int
  languageId     Int
  isNative       Boolean   @default(false)
  proficiency    String    @default("A1")
  isLearning     Boolean   @default(true)
  startedAt      DateTime  @default(now())
  lastStudied    DateTime?
  totalStudyTime Int       @default(0)
  language       Language  @relation(fields: [languageId], references: [id], onDelete: Cascade)
  user           user      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, languageId])
  @@index([languageId], map: "user_languages_languageId_fkey")
  @@map("user_languages")
}

model VocabTranslation {
  id          Int      @id @default(autoincrement())
  vocabId     Int
  languageId  Int
  translation String
  definition  String?  @db.Text
  examples    Json?
  confidence  Float    @default(1)
  isVerified  Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  language    Language @relation(fields: [languageId], references: [id], onDelete: Cascade)
  vocab       vocab    @relation(fields: [vocabId], references: [id], onDelete: Cascade)

  @@unique([vocabId, languageId])
  @@index([languageId], map: "vocab_translations_languageId_fkey")
  @@map("vocab_translations")
}

model CardReport {
  id          Int       @id @default(autoincrement())
  userId      Int
  vocabId     Int
  reportType  String
  description String?
  severity    String    @default("MEDIUM")
  status      String    @default("PENDING")
  frequency   Int       @default(1)
  metadata    Json?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  resolvedAt  DateTime?
  resolvedBy  Int?
  resolution  String?
  user        user      @relation(fields: [userId], references: [id], onDelete: Cascade)
  vocab       vocab     @relation(fields: [vocabId], references: [id], onDelete: Cascade)

  @@index([status, severity])
  @@index([reportType])
  @@index([createdAt])
  @@index([userId], map: "card_reports_userId_fkey")
  @@index([vocabId], map: "card_reports_vocabId_fkey")
  @@map("card_reports")
}

model AudioSource {
  id         Int      @id @default(autoincrement())
  languageId Int
  provider   String
  quality    String   @default("MEDIUM")
  voice      String?
  speed      Float    @default(1)
  isActive   Boolean  @default(true)
  priority   Int      @default(50)
  metadata   Json?
  createdAt  DateTime @default(now())
  language   Language @relation(fields: [languageId], references: [id], onDelete: Cascade)

  @@index([languageId], map: "audio_sources_languageId_fkey")
  @@map("audio_sources")
}

model StudySession {
  id                  Int       @id @default(autoincrement())
  userId              Int
  sessionType         String
  cardsStudied        Int       @default(0)
  cardsCorrect        Int       @default(0)
  averageResponseTime Float?
  totalStudyTime      Int       @default(0)
  startedAt           DateTime  @default(now())
  completedAt         DateTime?
  deviceType          String?
  studyContext        Json?
  performance         Json?
  user                user      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, startedAt])
  @@map("study_sessions")
}

model refreshToken {
  id         Int       @id @default(autoincrement())
  userId     Int
  token      String    @unique
  deviceId   String?
  deviceName String?
  userAgent  String?
  ipAddress  String?
  expiresAt  DateTime
  createdAt  DateTime  @default(now())
  lastUsedAt DateTime  @default(now())
  isRevoked  Boolean   @default(false)
  revokedAt  DateTime?
  user       user      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("refresh_tokens")
}
